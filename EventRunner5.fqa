{"files":[{"isOpen":false,"type":"lua","name":"erlib","content":"---@diagnostic disable: need-check-nil, undefined-global\nlocal lib = {}\nlocal fibemu = fibaro.fibemu\nfibaro.debugFlags = fibaro.debugFlags or {}\nfibaro.settings = fibaro.settings or {}\nlocal debugFlags = fibaro.debugFlags\nfibaro.utils = lib\n\nlocal function equal(e1,e2)\n  if e1==e2 then return true\n  else\n    if type(e1) ~= 'table' or type(e2) ~= 'table' then return false\n    else\n      for k1,v1 in pairs(e1) do if e2[k1] == nil or not equal(v1,e2[k1]) then return false end end\n      for k2,_  in pairs(e2) do if e1[k2] == nil then return false end end\n      return true\n    end\n  end\nend\n\nlocal function copy(t) if type(t) ~= 'table' then return t end local r = {} for k,v in pairs(t) do r[k] = copy(v) end return r end\nlocal function copyShallow(t) local r={} for k,v in pairs(t) do r[k]=v end return r end\nlocal function append(t1,t2) local r=copyShallow(t1); for _,e in ipairs(t2) do r[#r+1]=e end return r end\nlocal function maxn(t) local c=0 for i,_ in pairs(t) do c=i end return c end\nlocal function member(k,tab) for i,v in ipairs(tab) do if equal(v,k) then return i end end return false end\nlocal function map(f,l,s) s = s or 1; local r,m={},maxn(l) for i=s,m do r[#r+1] = f(l[i]) end return r end\nlocal function mapf(f,l,s) s = s or 1; local e=true for i=s,maxn(l) do e = f(l[i]) end return e end\nlocal function delete(k,tab) local i = member(tab,k); if i then table.remove(tab,i) return i end end\nlocal function mapAnd(f,l,s) s = s or 1; local e=true for i=s,table.maxn(l) do e = f(l[i]) if not e then return false end end return e end\nlocal function mapOr(f,l,s) s = s or 1; for i=s,table.maxn(l) do local e = f(l[i]) if e then return e end end return false end\nlocal function reduce(f,l) local r = {}; for _,e in ipairs(l) do if f(e) then r[#r+1]=e end end; return r end\nlocal function membermap(list) local r = {}; for _,e in ipairs(list) do r[e]=true end; return r end\nlocal function keys(list) local r = {}; for k,_ in pairs(list) do r[#r+1]=k end; return r end\nlocal function values(list) local r = {}; for _,v in pairs(list) do r[#r+1]=v end; return r end\nlocal function union(l1,l2) local r = membermap(l1); for _,e in ipairs(l2) do if not r[e] then r[e]=true end end; return keys(r) end\nlocal function intersection(l1,l2) local l,r = membermap(l1),{}; for _,e in ipairs(l2) do if r[e] then r[#r+1]=e end end; return r end\nlocal function mapk(f,l) local r={}; for k,v in pairs(l) do r[k]=f(v) end; return r end\nlocal function mapkv(f,l) local r={}; for k,v in pairs(l) do k,v=f(k,v) if k then r[k]=v end end; return r end\nlocal function mapkl(f,l) local r={} for i,j in pairs(l) do r[#r+1]=f(i,j) end return r end\nlocal function packArray(arr,n) return {table.unpack(arr,1,n or maxn(arr))} end\n\nif not table.maxn then table.maxn = maxn end\ntable.packArray = packArray\ntable.copy,table.copyShallow,table.equal,table.max,table.member,table.map,table.mapf,table.delete,table.append,table.union,table.intersection = \ncopy,      copyShallow,      equal,      maxn,     member,      map,      mapf,      delete,      append,      union,      intersection\ntable.mapAnd,table.mapOr,table.reduce,table.mapk,table.mapkv,table.mapkl = mapAnd,mapOr,reduce,mapk,mapkv,mapkl\n\nlocal fmt = string.format\nlocal function gensym(s) return (s or \"G\")..tostring({}):match(\"%s(.*)\") end\n\nlocal encode\ndo -- fastEncode\n  local fmt = string.format\n  local function encTsort(a,b) return a[1] < b[1] end\n  local sortKeys = {\"type\",\"device\",\"deviceID\",\"id\",\"value\",\"oldValue\",\"val\",\"key\",\"arg\",\"event\",\"events\",\"msg\",\"res\"}\n  local sortOrder,sortF={},nil\n  for i,s in ipairs(sortKeys) do sortOrder[s]=\"\\n\"..string.char(i+64)..\" \"..s end\n  local function encEsort(a,b)\n    a,b=a[1],b[1]; a,b = sortOrder[a] or a, sortOrder[b] or b\n    return tostring(a) < tostring(b)\n  end\n  function table.maxn(t) local c=0 for i,_ in pairs(t) do c=i end return c end\n  local encT={}\n  encT['nil'] = function(n,out) out[#out+1]='nil' end\n  function encT.number(n,out) out[#out+1]=tostring(n) end\n  function encT.userdata(u,out) out[#out+1]=tostring(u) end\n  function encT.thread(t,out) out[#out+1]=tostring(t) end\n  encT['function'] = function(f,out) out[#out+1]=tostring(f) end\n  function encT.string(str,out) out[#out+1]='\"' out[#out+1]=str out[#out+1]='\"' end\n  function encT.boolean(b,out) out[#out+1]=b and \"true\" or \"false\" end\n  function encT.table(t,out,f)\n    local mt = getmetatable(t) if mt and (not f) and mt.__tostring then return mt.__tostring(t) end\n    if next(t)==nil then out[#out+1]= \"{}\" return -- Empty table\n    elseif t[1]==nil then -- key value table\n      local r = {}; for k,v in pairs(t) do r[#r+1]={k,v} end table.sort(r,sortF)\n      out[#out+1]='{'\n      local e = r[1]\n      out[#out+1]=e[1]; out[#out+1]='='; encT[type(e[2])](e[2],out)\n      for i=2,table.maxn(r) do local e = r[i]; out[#out+1]=','; out[#out+1]=e[1]; out[#out+1]='='; encT[type(e[2])](e[2],out) end\n      out[#out+1]='}'\n    else -- array table\n      out[#out+1]='['\n      encT[type(t[1])](t[1],out)\n      for i=2,table.maxn(t) do out[#out+1]=',' encT[type(t[ i])](t[i],out) end\n      out[#out+1]=']'\n    end\n  end\n  \n  function encode(o,sort,f)\n    local out = {}\n    sortF = (not sort) and encEsort or encTsort\n    encT[type(o)](o,out,f)\n    return table.concat(out)\n  end\n  lib.encode = encode\n  json.encodeFast = encode\nend\n\nlocal eventMT = { \n  __tostring = function(ev)\n    local s = encode(ev,nil,true)\n    return fmt(\"#%s{%s}\",ev.type,s:match(\",(.*)}\") or \"\") end\n  }\n  \n  local function shallowCopy(t) local r = {}; for k,v in pairs(t) do r[k]=v end; return r end\n  local EventMT = {\n    __tostring = function(ev)\n      local s = encode(ev,nil,true)\n      return fmt(\"#%s{%s}\",ev.type or \"unknown\",s:match(\",(.*)}\") or \"\")\n    end,\n  }\n  \n  ----------- spec format -----------------------------\n  do\n    local function hm(t)\n      if t > 3600*100 then return os.date(\"%H:%M\",t)\n      else return fmt(\"%2d:%2d\",t\/\/3600,t % 3600 \/\/ 60) end\n    end\n    local function hms(t)\n      if t > 3600*100 then return os.date(\"%X\",t)\n      else return fmt(\"%2d:%2d:%2d\",t\/\/3600,t % 3600 \/\/ 60,t % 60) end\n    end\n    \n    local function mkTruncer(n,fun,a) return function(s) return fun(s):sub(1,n),a end end\n    local function mkSpacer(n,fun,a)\n      local e = n < 0 and 1 or 0\n      n = math.abs(n)\n      return function(s)\n        s = fun(s)\n        local l = #s\n        if l>=n then return s,a\n        else return e==1 and (s..string.rep(' ',n-l)) or (string.rep(' ',n-l)..s),a end\n      end\n    end\n    \n    local specs = {}\n    function specs.s(f)\n      local fun = function(s) return tostring(s),1 end\n      local space,trunc = f:match(\"(-?%d*),?(%d*)\")\n      if trunc and trunc~=\"\" then fun = mkTruncer(tonumber(trunc),fun,1) end\n      if space and space~=\"\" then fun = mkSpacer(tonumber(space),fun,1) end\n      return fun\n    end\n    function specs.d(f) f = \"%\"..f..\"d\" return function(s) return fmt(f,s),1 end end\n    function specs.f(f) f = \"%\"..f..\"f\" return function(s) return fmt(f,s),1 end end\n    function specs.x(f) f = \"%\"..f..\"x\" return function(s) return fmt(f,s),1 end end\n    function specs.o(f) f = \"%\"..f..\"o\" return function(s) return fmt(f,s),1 end end\n    function specs.t(f)\n      local s = f:match(\".\")\n      if s then return function(s) return hms(s),1 end else return function(s) return hm(s),1 end end\n    end\n    string._edelimter = \", \"\n    function specs.l(f)\n      local fun = function(s)\n        local r = {} for _,e in ipairs(s) do r[#r+1]=tostring(e) end\n        return table.concat(r,string._edelimter),1\n      end\n      local space,trunc = f:match(\"(-?%d*),?(%d*)\")\n      if trunc and trunc~=\"\" then fun = mkTruncer(tonumber(trunc),fun,1) end\n      if space and space~=\"\" then fun = mkSpacer(tonumber(space),fun,1) end\n      return fun\n    end\n    function specs.r(f)\n      local n,c = f:match(\"%d*%w?\")\n      n = tonumber(n) or 80\n      c = c~= \"\" and c or \"-\"\n      return function() return c:rep(n),0 end\n    end\n    \n    local fmtcache = {}\n    function string.eformat(fmt,...)\n      local frms = fmtcache[fmt]\n      if not frms then\n        local forms,strs,globs,n = {},{},{},0\n        local res,rest = {},\"\"\n        fmt = fmt:gsub(\"(.-)%%([%d%-%.,%w%*]*)([sfdxlotr])\",\n        function(p,s,f)\n          res[#res+1]=p\n          local fun = specs[f](s)\n          assert(fun,\"Bad format specifier\")\n          res[#res+1]=fun\n          return \"\"\n        end)\n        if fmt~=\"\" then res[#res+1]=fmt end\n        for i,p in ipairs(res) do\n          if type(p) == 'string' then\n            if p ~= \"\" then\n              n=n+1\n              strs[n]=p\n            end\n          else n=n+1 forms[#forms+1] = {i=n,f=p} end\n        end\n        frms = {forms=forms,strs=strs,globs=globs}\n        fmtcache[fmt]=frms\n      end\n      local i,n,args,forms,strs,globs = 1,0,{...},frms.forms,frms.strs,frms.globs\n      local stat,res = pcall(function()\n        for _,f in ipairs(forms) do strs[f.i],n = f.f(args[i],i,args) i=i+n end\n        local str = table.concat(strs)\n        if globs[1] then\n          for _,g in ipairs(globs) do str = g(str) end\n        end\n        return str\n      end)\n      if stat then return res\n      else error(string.format(\"Bad argument to string.eformat specifier #%s - '%s'\",i,tostring(args[i]))) end\n    end\n    \n    getmetatable(\"\").__idiv = function(str,len) return (#str < len or #str < 4) and str or str:sub(1,len-2)..\"..\" end -- truncate strings\n  end\n  \n  ----------------------- Net stuff ---------------------------\n  local function base64encode(data)\n    __assert_type(data,\"string\")\n    local bC='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+\/'\n    return ((data:gsub('.', function(x)\n      local r,b='',x:byte() for i=8,1,-1 do r=r..(b%2^i-b%2^(i-1)>0 and '1' or '0') end\n      return r;\n    end)..'0000'):gsub('%d%d%d?%d?%d?%d?', function(x)\n      if (#x < 6) then return '' end\n      local c=0\n      for i=1,6 do c=c+(x:sub(i,i)=='1' and 2^(6-i) or 0) end\n      return bC:sub(c+1,c+1)\n    end)..({ '', '==', '=' })[#data%3+1])\n  end\n  \n  local function basicAuthorization(user,password) return \"Basic \"..base64encode(user..\":\"..password) end\n  \n  function urlencode(str) -- very useful\n    if str then\n      str = str:gsub(\"\\n\", \"\\r\\n\")\n      str = str:gsub(\"([^%w %-%_%.%~])\", function(c)\n        return (\"%%%02X\"):format(string.byte(c))\n      end)\n      str = str:gsub(\" \", \"%%20\")\n    end\n    return str\n  end\n  local function getIPaddress(name)\n    if IPaddress then return IPaddress end\n    if fibemu then return fibemu.config.hostIP..\":\"..fibemu.config.wport\n    else\n      name = name or \".*\"\n      local networkdata = api.get(\"\/proxy?url=http:\/\/localhost:11112\/api\/settings\/network\")\n      for n,d in pairs(networkdata.networkConfig or {}) do\n        if n:match(name) and d.enabled then IPaddress = d.ipConfig.ip; return IPaddress end\n      end\n    end\n  end\n  fibaro.getIPaddress = getIPaddress\n  fibaro.basicAuthorization = basicAuthorization\n  \n  ---------------- Debug ---------------------------------------------\n  function QuickApp:debugf(fmt,...) self:debug(fmt:format(...)) end\n  function QuickApp:tracef(fmt,...) self:trace(fmt:format(...)) end\n  function QuickApp:warningf(fmt,...) self:warning(fmt:format(...)) end\n  function QuickApp:errorf(fmt,...) self:error(fmt:format(...)) end\n  \n  local timerMT = {\n    __tostring = function(t) return fmt(\"[Timer:%d%s %s]\",t.n,t.log or \"\",os.date('%T %D',t.expires or 0)) end\n  }\n  \n  local N,NC = 0,0\n  local function isTimer(timer) return type(timer)=='table' and timer['%TIMER%'] end\n  local function makeTimer(ref,log,exp)\n    N=N+1\n    return setmetatable({['%TIMER%']=(ref or 0),n=N,log=type(log)=='string' and \" (\"..log..\")\" or nil,expires=exp or 0},timerMT)\n  end\n  local function updateTimer(timer,ref) timer['%TIMER%']=ref end\n  local function getTimer(timer) return timer['%TIMER%'] end\n  \n  local oldClearTimout,oldSetTimout\n  clearTimeout,oldClearTimout=function(ref)\n    if isTimer(ref) then ref=getTimer(ref) oldClearTimout(ref) end\n  end,clearTimeout\n  \n  setTimeout,oldSetTimout=function(f,ms,log)\n    local ref,maxt=makeTimer(nil,log,math.floor(os.time()+ms\/1000+0.5)),2147483648-1\n    local fun = function() -- wrap function to get error messages\n      if debugFlags.lateTimer then\n        local d = os.time() - ref.expires\n        if d > debugFlags.lateTimer then fibaro.warning(__TAG,fmt(\"Late timer (%ds):%s\",d,tostring(ref))) end\n      end\n      NC = NC-1\n      ref.expired = true\n      if ref._prehook then ref._prehook() end -- pre and posthooks\n      local stat,res = pcall(f)\n      if ref._posthook then ref._posthook() end\n      if not stat then\n        fibaro.error(__TAG,res)\n      end\n    end\n    NC = NC+1\n    if ms > maxt then -- extend timer length > 26 days...\n      updateTimer(ref,oldSetTimout(function() updateTimer(ref,getTimer(setTimeout(fun,ms-maxt))) end,maxt))\n    else updateTimer(ref,oldSetTimout(fun,math.floor(ms+0.5))) end\n    return ref\n  end,setTimeout\n  \n  local oldClearInterval,oldSetInterval = clearInterval,setInterval\n  function setInterval(fun,ms) -- can't manage looong intervals\n    return oldSetInterval(function()\n      local stat,res = pcall(fun)\n      if not stat then\n        fibaro.error(__TAG,res)\n      end\n    end,math.floor(ms+0.5))\n  end\n  fibaro.setTimeout = function(ms,fun) return setTimeout(fun,ms) end\n  fibaro.clearTimeout = function(ref) return clearTimeout(ref) end\n  \n  local encode2,decode2 = json.encode,json.decode\n  function json.decode(...)\n    local stat,res = pcall(decode2,...)\n    if not stat then error(res,2) else return res end\n  end\n  function json.encode(...)\n    local stat,res = pcall(encode2,...)\n    if not stat then error(res,2) else return res end\n  end\n  \n  --------------- Time and Sun calc  functions -----------------------\n  do\n    local function toSeconds(str)\n      __assert_type(str,\"string\" )\n      local sun = str:match(\"(sun%a+)\")\n      if sun then return toSeconds(str:gsub(sun,fibaro.getValue(1,sun..\"Hour\"))) end\n      local var = str:match(\"(%$[A-Za-z]+)\")\n      if var then return toSeconds(str:gsub(var,fibaro.getGlobalVariable(var:sub(2)))) end\n      local h,m,s,op,off=str:match(\"(%d%d):(%d%d):?(%d*)([+%-]*)([%d:]*)\")\n      off = off~=\"\" and (off:find(\":\") and toSeconds(off) or toSeconds(\"00:00:\"..off)) or 0\n      return 3600*h+60*m+(s~=\"\" and s or 0)+((op=='-' or op =='+-') and -1 or 1)*off\n    end\n    lib.toSeconds = toSeconds\n    \n    ---@diagnostic disable-next-line: param-type-mismatch\n    local function midnight() local t = os.date(\"*t\"); t.hour,t.min,t.sec = 0,0,0; return os.time(t) end\n    lib.midnight = midnight\n    function lib.getWeekNumber(tm) return tonumber(os.date(\"%V\",tm)) end\n    function lib.now() return os.time()-midnight() end\n    \n    function lib.between(start,stop,optTime)\n      __assert_type(start,\"string\" )\n      __assert_type(stop,\"string\" )\n      start,stop,optTime=toSeconds(start),toSeconds(stop),optTime and toSeconds(optTime) or toSeconds(os.date(\"%H:%M\"))\n      stop = stop>=start and stop or stop+24*3600\n      optTime = optTime>=start and optTime or optTime+24*3600\n      return start <= optTime and optTime <= stop\n    end\n    function lib.time2str(t) return fmt(\"%02d:%02d:%02d\",math.floor(t\/3600),math.floor((t%3600)\/60),t%60) end\n    \n    local function hm2sec(hmstr,ns)\n      local offs,sun\n      sun,offs = hmstr:match(\"^(%a+)([+-]?%d*)\")\n      if sun and (sun == 'sunset' or sun == 'sunrise') then\n        if ns then\n          local sunrise,sunset = fibaro.utils.sunCalc(os.time()+24*3600)\n          hmstr,offs = sun=='sunrise' and sunrise or sunset, tonumber(offs) or 0\n        else\n          hmstr,offs = fibaro.getValue(1,sun..\"Hour\"), tonumber(offs) or 0\n        end\n      end\n      local sg,h,m,s = hmstr:match(\"^(%-?)(%d+):(%d+):?(%d*)\")\n      if not (h and m) then error(fmt(\"Bad hm2sec string %s\",hmstr)) end\n      return (sg == '-' and -1 or 1)*(tonumber(h)*3600+tonumber(m)*60+(tonumber(s) or 0)+(tonumber(offs or 0))*60)\n    end\n    \n    -- toTime(\"10:00\")     -> 10*3600+0*60 secs\n    -- toTime(\"10:00:05\")  -> 10*3600+0*60+5*1 secs\n    -- toTime(\"t\/10:00\")    -> (t)oday at 10:00. midnight+10*3600+0*60 secs\n    -- toTime(\"n\/10:00\")    -> (n)ext time. today at 10.00AM if called before (or at) 10.00AM else 10:00AM next day\n    -- toTime(\"+\/10:00\")    -> Plus time. os.time() + 10 hours\n    -- toTime(\"+\/00:01:22\") -> Plus time. os.time() + 1min and 22sec\n    -- toTime(\"sunset\")     -> todays sunset in relative secs since midnight, E.g. sunset=\"05:10\", =>toTime(\"05:10\")\n    -- toTime(\"sunrise\")    -> todays sunrise\n    -- toTime(\"sunset+10\")  -> todays sunset + 10min. E.g. sunset=\"05:10\", =>toTime(\"05:10\")+10*60\n    -- toTime(\"sunrise-5\")  -> todays sunrise - 5min\n    -- toTime(\"t\/sunset+10\")-> (t)oday at sunset in 'absolute' time. E.g. midnight+toTime(\"sunset+10\")\n    \n    local function toTime(time)\n      if type(time) == 'number' then return time end\n      local p = time:sub(1,2)\n      if p == '+\/' then return hm2sec(time:sub(3))+os.time()\n      elseif p == 'n\/' then\n        local t1,t2 = midnight()+hm2sec(time:sub(3),true),os.time()\n        return t1 > t2 and t1 or t1+24*60*60\n      elseif p == 't\/' then return  hm2sec(time:sub(3))+midnight()\n      else return hm2sec(time) end\n    end\n    lib.toTime,lib.hm2sec = toTime,hm2sec\n    \n    local function sunturnTime(date, rising, latitude, longitude, zenith, local_offset)\n      local rad,deg,floor = math.rad,math.deg,math.floor\n      local frac = function(n) return n - floor(n) end\n      local cos = function(d) return math.cos(rad(d)) end\n      local acos = function(d) return deg(math.acos(d)) end\n      local sin = function(d) return math.sin(rad(d)) end\n      local asin = function(d) return deg(math.asin(d)) end\n      local tan = function(d) return math.tan(rad(d)) end\n      local atan = function(d) return deg(math.atan(d)) end\n      \n      local function day_of_year(date2)\n        local n1 = floor(275 * date2.month \/ 9)\n        local n2 = floor((date2.month + 9) \/ 12)\n        local n3 = (1 + floor((date2.year - 4 * floor(date2.year \/ 4) + 2) \/ 3))\n        return n1 - (n2 * n3) + date2.day - 30\n      end\n      \n      local function fit_into_range(val, min, max)\n        local range,count = max - min,nil\n        if val < min then count = floor((min - val) \/ range) + 1; return val + count * range\n        elseif val >= max then count = floor((val - max) \/ range) + 1; return val - count * range\n        else return val end\n      end\n      \n      -- Convert the longitude to hour value and calculate an approximate time\n      local n,lng_hour,t =  day_of_year(date), longitude \/ 15,nil\n      if rising then t = n + ((6 - lng_hour) \/ 24) -- Rising time is desired\n      else t = n + ((18 - lng_hour) \/ 24) end -- Setting time is desired\n      local M = (0.9856 * t) - 3.289 -- Calculate the Sun^s mean anomaly\n      -- Calculate the Sun^s true longitude\n      local L = fit_into_range(M + (1.916 * sin(M)) + (0.020 * sin(2 * M)) + 282.634, 0, 360)\n      -- Calculate the Sun^s right ascension\n      local RA = fit_into_range(atan(0.91764 * tan(L)), 0, 360)\n      -- Right ascension value needs to be in the same quadrant as L\n      local Lquadrant = floor(L \/ 90) * 90\n      local RAquadrant = floor(RA \/ 90) * 90\n      RA = RA + Lquadrant - RAquadrant; RA = RA \/ 15 -- Right ascension value needs to be converted into hours\n      local sinDec = 0.39782 * sin(L) -- Calculate the Sun's declination\n      local cosDec = cos(asin(sinDec))\n      local cosH = (cos(zenith) - (sinDec * sin(latitude))) \/ (cosDec * cos(latitude)) -- Calculate the Sun^s local hour angle\n      if rising and cosH > 1 then return -1 --\"N\/R\" -- The sun never rises on this location on the specified date\n      elseif cosH < -1 then return -1 end --\"N\/S\" end -- The sun never sets on this location on the specified date\n      \n      local H -- Finish calculating H and convert into hours\n      if rising then H = 360 - acos(cosH)\n      else H = acos(cosH) end\n      H = H \/ 15\n      local T = H + RA - (0.06571 * t) - 6.622 -- Calculate local mean time of rising\/setting\n      local UT = fit_into_range(T - lng_hour, 0, 24) -- Adjust back to UTC\n      local LT = UT + local_offset -- Convert UT value to local time zone of latitude\/longitude\n      ---@diagnostic disable-next-line: missing-fields\n      return os.time({day = date.day,month = date.month,year = date.year,hour = floor(LT),min = math.modf(frac(LT) * 60)})\n    end\n    \n    ---@diagnostic disable-next-line: param-type-mismatch\n    local function getTimezone() local now = os.time() return os.difftime(now, os.time(os.date(\"!*t\", now))) end\n    \n    function lib.sunCalc(time)\n      local hc3Location = api.get(\"\/settings\/location\")\n      local lat = hc3Location.latitude or 0\n      local lon = hc3Location.longitude or 0\n      local utc = getTimezone() \/ 3600\n      local zenith,zenith_twilight = 90.83, 96.0 -- sunset\/sunrise 90°50′, civil twilight 96°0′\n      \n      local date = os.date(\"*t\",time or os.time())\n      if date.isdst then utc = utc + 1 end\n      local rise_time = os.date(\"*t\", sunturnTime(date, true, lat, lon, zenith, utc))\n      local set_time = os.date(\"*t\", sunturnTime(date, false, lat, lon, zenith, utc))\n      local rise_time_t = os.date(\"*t\", sunturnTime(date, true, lat, lon, zenith_twilight, utc))\n      local set_time_t = os.date(\"*t\", sunturnTime(date, false, lat, lon, zenith_twilight, utc))\n      local sunrise = fmt(\"%.2d:%.2d\", rise_time.hour, rise_time.min)\n      local sunset = fmt(\"%.2d:%.2d\", set_time.hour, set_time.min)\n      local sunrise_t = fmt(\"%.2d:%.2d\", rise_time_t.hour, rise_time_t.min)\n      local sunset_t = fmt(\"%.2d:%.2d\", set_time_t.hour, set_time_t.min)\n      return sunrise, sunset, sunrise_t, sunset_t\n    end\n    \n    local function dateTest(dateStr0)\n      local days = {sun=1,mon=2,tue=3,wed=4,thu=5,fri=6,sat=7}\n      local months = {jan=1,feb=2,mar=3,apr=4,may=5,jun=6,jul=7,aug=8,sep=9,oct=10,nov=11,dec=12}\n      local last,month = {31,28,31,30,31,30,31,31,30,31,30,31},nil\n      \n      local function seq2map(seq) local s = {} for _,v in ipairs(seq) do s[v] = true end return s; end\n      \n      local function flatten(seq,res) -- flattens a table of tables\n        res = res or {}\n        if type(seq) == 'table' then for _,v1 in ipairs(seq) do flatten(v1,res) end else res[#res+1] = seq end\n        return res\n      end\n      \n      local function _assert(test,msg,...) if not test then error(fmt(msg,...),3) end end\n      \n      local function expandDate(w1,md)\n        local function resolve(id)\n          local res\n          if id == 'last' then month = md res=last[md]\n          elseif id == 'lastw' then month = md res=last[md]-6\n          else res= type(id) == 'number' and id or days[id] or months[id] or tonumber(id) end\n          _assert(res,\"Bad date specifier '%s'\",id) return res\n        end\n        local step = tonumber(1)\n        local w,m = w1[1],w1[2]\n        local start,stop = w:match(\"(%w+)%p(%w+)\")\n        if (start == nil) then return resolve(w) end\n        start,stop = resolve(start), resolve(stop)\n        local res,res2 = {},{}\n        if w:find(\"\/\") then\n          if not w:find(\"-\") then -- 10\/2\n            step=stop; stop = m.max\n          else step=(w:match(\"\/(%d+)\")) end\n        end\n        step = tonumber(step)\n        _assert(start>=m.min and start<=m.max and stop>=m.min and stop<=m.max,\"illegal date intervall\")\n        while (start ~= stop) do -- 10-2\n          res[#res+1] = start\n          start = start+1; if start>m.max then start=m.min end\n        end\n        res[#res+1] = stop\n        if step > 1 then for i=1,#res,step do res2[#res2+1]=res[i] end; res=res2 end\n        return res\n      end\n      \n      local function parseDateStr(dateStr) --,last)\n        local map = table.map\n        local seq = string.split(dateStr,\" \")   -- min,hour,day,month,wday\n        local lim = {{min=0,max=59},{min=0,max=23},{min=1,max=31},{min=1,max=12},{min=1,max=7},{min=2000,max=3000}}\n        for i=1,6 do if seq[i]=='*' or seq[i]==nil then seq[i]=tostring(lim[i].min)..\"-\"..lim[i].max end end\n        seq = map(function(w) return string.split(w,\",\") end, seq)   -- split sequences \"3,4\"\n        local month0 = os.date(\"*t\",os.time()).month\n        seq = map(function(t) local m = table.remove(lim,1);\n          return flatten(map(function (g) return expandDate({g,m},month0) end, t))\n        end, seq) -- expand intervalls \"3-5\"\n        return map(seq2map,seq)\n      end\n      local sun,offs,day,sunPatch = dateStr0:match(\"^(sun%a+) ([%+%-]?%d+)\")\n      if sun then\n        sun = sun..\"Hour\"\n        dateStr0=dateStr0:gsub(\"sun%a+ [%+%-]?%d+\",\"0 0\")\n        sunPatch=function(dateSeq)\n          local h,m = (fibaro.getValue(1,sun)):match(\"(%d%d):(%d%d)\")\n          dateSeq[1]={[(tonumber(h)*60+tonumber(m)+tonumber(offs))%60]=true}\n          dateSeq[2]={[math.floor((tonumber(h)*60+tonumber(m)+tonumber(offs))\/60)]=true}\n        end\n      end\n      local dateSeq = parseDateStr(dateStr0)\n      return function() -- Pretty efficient way of testing dates...\n        local t = os.date(\"*t\",os.time())\n        if month and month~=t.month then dateSeq=parseDateStr(dateStr0) end -- Recalculate 'last' every month\n        if sunPatch and (month and month~=t.month or day~=t.day) then sunPatch(dateSeq) day=t.day end -- Recalculate sunset\/sunrise\n        return\n        dateSeq[1][t.min] and    -- min     0-59\n        dateSeq[2][t.hour] and   -- hour    0-23\n        dateSeq[3][t.day] and    -- day     1-31\n        dateSeq[4][t.month] and  -- month   1-12\n        dateSeq[5][t.wday] or false      -- weekday 1-7, 1=sun, 7=sat\n      end\n    end\n    \n    fibaro.dateTest = dateTest\n  end\n  \n  --------------- Event engine -------------------\n  local function createEventEngine()\n    local self = {}\n    local HANDLER = '%EVENTHANDLER%'\n    local BREAK = '%BREAK%'\n    self.BREAK = BREAK\n    local handlers = {}\n    local function isEvent(e) return type(e) == 'table' and type(e.type)=='string' end\n    \n    local function coerce(x,y) local x1 = tonumber(x) if x1 then return x1,tonumber(y) else return x,y end end\n    local constraints = {}\n    constraints['=='] = function(val) return function(x) x,val=coerce(x,val) return x == val end end\n    constraints['<>'] = function(val) return function(x) return tostring(x):match(val) end end\n    constraints['>='] = function(val) return function(x) x,val=coerce(x,val) return x >= val end end\n    constraints['<='] = function(val) return function(x) x,val=coerce(x,val) return x <= val end end\n    constraints['>'] = function(val) return function(x) x,val=coerce(x,val) return x > val end end\n    constraints['<'] = function(val) return function(x) x,val=coerce(x,val) return x < val end end\n    constraints['~='] = function(val) return function(x) x,val=coerce(x,val) return x ~= val end end\n    constraints[''] = function(_) return function(x) return x ~= nil end end\n    \n    local function compilePattern2(pattern)\n      if type(pattern) == 'table' then\n        if pattern._var_ then return end\n        for k,v in pairs(pattern) do\n          if type(v) == 'string' and v:sub(1,1) == '$' then\n            local var,op,val = v:match(\"$([%w_]*)([<>=~]*)(.*)\")\n            var = var ==\"\" and \"_\" or var\n            local c = constraints[op](tonumber(val) or val)\n            pattern[k] = {_var_=var, _constr=c, _str=v}\n          else compilePattern2(v) end\n        end\n      end\n      return pattern\n    end\n    \n    local function compilePattern(pattern)\n      pattern = compilePattern2(copy(pattern))\n      if pattern.type and type(pattern.id)=='table' and not pattern.id._constr then\n        local m = {}; for _,id in ipairs(pattern.id) do m[id]=true end\n        pattern.id = {_var_='_', _constr=function(val) return m[val] end, _str=pattern.id}\n      end\n      return pattern\n    end\n    self.compilePattern = compilePattern\n    \n    local function match(pattern0, expr0)\n      local matches = {}\n      local function unify(pattern,expr)\n        if pattern == expr then return true\n        elseif type(pattern) == 'table' then\n          if pattern._var_ then\n            local var, constr = pattern._var_, pattern._constr\n            if var == '_' then return constr(expr)\n            elseif matches[var] then return constr(expr) and unify(matches[var],expr) -- Hmm, equal?\n            else matches[var] = expr return constr(expr) end\n          end\n          if type(expr) ~= \"table\" then return false end\n          for k,v in pairs(pattern) do if not unify(v,expr[k]) then return false end end\n          return true\n        else return false end\n      end\n      return unify(pattern0,expr0) and matches or false\n    end\n    self.match = match\n    \n    local function invokeHandler(env)\n      local t = os.time()\n      env.last,env.rule.time = t-(env.rule.time or 0),t\n      local status, res = pcall(env.rule.action,env) -- call the associated action\n      if not status then\n        --if type(res)=='string' and not debugFlags.extendedErrors then res = res:gsub(\"(%[.-%]:%d+:)\",\"\") end\n        --fibaro.errorf(nil,\"in %s: %s\",env.rule.doc,res)\n        env.rule._disabled = true -- disable rule to not generate more errors\n        --em.stats.errors=(em.stats.errors or 0)+1\n      else return res end\n    end\n    \n    local toTime = self.toTime\n    function self.post(ev,t,log,hook,customLog)\n      local now,isEv = os.time(),isEvent(ev)\n      t = type(t)=='string' and toTime(t) or t or 0\n      if t < 0 then return elseif t < now then t = t+now end\n      if debugFlags.post and (type(ev)=='function' or not ev._sh) then\n        if isEv and not getmetatable(ev) then setmetatable(ev,EventMT) end\n        (customLog or fibaro.trace)(__TAG,fmt(\"Posting %s at %s %s\",tostring(ev),os.date(\"%c\",t),type(log)=='string' and (\"(\"..log..\")\") or \"\"))\n      end\n      if type(ev) == 'function' then\n        return setTimeout(function() ev(ev) end,1000*(t-now),log),t\n      elseif isEv then\n        if not getmetatable(ev) then setmetatable(ev,EventMT) end\n        return setTimeout(function() if hook then hook() end self.handleEvent(ev) end,1000*(t-now),log),t\n      else\n        error(\"post(...) not event or fun;\"..tostring(ev))\n      end\n    end\n    \n    function self.cancel(id) clearTimeout(id) end\n    \n    local toHash,fromHash={},{}\n    fromHash['device'] = function(e) return {\"device\"..e.id..e.property,\"device\"..e.id,\"device\"..e.property,\"device\"} end\n    fromHash['global-variable'] = function(e) return {'global-variable'..e.name,'global-variable'} end\n    fromHash['quickvar'] = function(e) return {\"quickvar\"..e.id..e.name,\"quickvar\"..e.id,\"quickvar\"..e.name,\"quickvar\"} end\n    fromHash['profile'] = function(e) return {'profile'..e.property,'profile'} end\n    fromHash['weather'] = function(e) return {'weather'..e.property,'weather'} end\n    fromHash['custom-event'] = function(e) return {'custom-event'..e.name,'custom-event'} end\n    fromHash['deviceEvent'] = function(e) return {\"deviceEvent\"..e.id..e.value,\"deviceEvent\"..e.id,\"deviceEvent\"..e.value,\"deviceEvent\"} end\n    fromHash['sceneEvent'] = function(e) return {\"sceneEvent\"..e.id..e.value,\"sceneEvent\"..e.id,\"sceneEvent\"..e.value,\"sceneEvent\"} end\n    toHash['device'] = function(e) return \"device\"..(e.id or \"\")..(e.property or \"\") end\n    \n    toHash['global-variable'] = function(e) return 'global-variable'..(e.name or \"\") end\n    toHash['quickvar'] = function(e) return 'quickvar'..(e.id or \"\")..(e.name or \"\") end\n    toHash['profile'] = function(e) return 'profile'..(e.property or \"\") end\n    toHash['weather'] = function(e) return 'weather'..(e.property or \"\") end\n    toHash['custom-event'] = function(e) return 'custom-event'..(e.name or \"\") end\n    toHash['deviceEvent'] = function(e) return 'deviceEvent'..(e.id or \"\")..(e.value or \"\") end\n    toHash['sceneEvent'] = function(e) return 'sceneEvent'..(e.id or \"\")..(e.value or \"\") end\n    \n    \n    local MTrule = { __tostring = function(self) return fmt(\"SourceTriggerSub:%s\",self.event.type) end }\n    function self.addEventHandler(pattern,fun,doc)\n      if not isEvent(pattern) then error(\"Bad event pattern, needs .type field\") end\n      assert(type(fun)=='func'..'tion', \"Second argument must be Lua func\")\n      local cpattern = compilePattern(pattern)\n      local rule,hashKeys = {[HANDLER]=cpattern, event=pattern, action=fun, doc=doc},{}\n      if toHash[pattern.type] and pattern.id and type(pattern.id) == 'table' then\n        local oldid=pattern.id\n        for _,id in ipairs(pattern.id) do\n          pattern.id = id\n          hashKeys[#hashKeys+1] = toHash[pattern.type](pattern)\n          pattern.id = oldid\n        end\n      else hashKeys = {toHash[pattern.type] and toHash[pattern.type](pattern) or pattern.type} end\n      for _,hashKey in ipairs(hashKeys) do\n        handlers[hashKey] = handlers[hashKey] or {}\n        local rules,fn = handlers[hashKey],true\n        for _,rs in ipairs(rules) do -- Collect handlers with identical patterns. {{e1,e2,e3},{e1,e2,e3}}\n          if equal(cpattern,rs[1].event) then\n            rs[#rs+1] = rule\n            fn = false break\n          end\n        end\n        if fn then rules[#rules+1] = {rule} end\n      end\n      rule.enable = function() rule._disabled = nil return rule end\n      rule.disable = function() rule._disabled = true return rule end\n      return rule\n    end\n    \n    function self.removeEventHandler(rule)\n      local pattern,fun = rule.event,rule.action\n      local hashKey = toHash[pattern.type] and toHash[pattern.type](pattern) or pattern.type\n      local rules,i,j= handlers[hashKey] or {},1,1\n      while j <= #rules do\n        local rs = rules[j]\n        while i <= #rs do\n          if rs[i].action==fun then\n            table.remove(rs,i)\n          else i=i+i end\n        end\n        if #rs==0 then table.remove(rules,j) else j=j+1 end\n      end\n    end\n    \n    local callbacks = {}\n    function self.registerCallback(fun) callbacks[#callbacks+1] = fun end\n    \n    function self.handleEvent(ev,firingTime)\n      for _,cb in ipairs(callbacks) do cb(ev) end\n      \n      local hasKeys = fromHash[ev.type] and fromHash[ev.type](ev) or {ev.type}\n      for _,hashKey in ipairs(hasKeys) do\n        for _,rules in ipairs(handlers[hashKey] or {}) do -- Check all rules of 'type'\n          local i,m=1,nil\n          for j=1,#rules do\n            if not rules[j]._disabled then    -- find first enabled rule, among rules with same head\n              m = match(rules[i][HANDLER],ev) -- and match against that rule\n              break\n            end\n          end\n          if m then                           -- we have a match\n            for j=i,#rules do                 -- executes all rules with same head\n              local rule=rules[j]\n              if not rule._disabled then\n                if invokeHandler({event = ev, time = firingTime, p=m, rule=rule}) == BREAK then return end\n              end\n            end\n          end\n        end\n      end\n    end\n    \n    -- This can be used to \"post\" an event into this QA... Ex. fibaro.call(ID,'RECIEVE_EVENT',{type='myEvent'})\n    function QuickApp.RECIEVE_EVENT(_,ev)\n      assert(isEvent(ev),\"Bad argument to remote event\")\n      local time = ev.ev._time\n      ev,ev.ev._time = ev.ev,nil\n      setmetatable(ev,EventMT)\n      if time and time+5 < os.time() then fibaro.warning(__TAG,fmt(\"Slow events %s, %ss\",tostring(ev),os.time()-time)) end\n      self.post(ev)\n    end\n    \n    function self.postRemote(uuid,id,ev)\n      if ev == nil then\n        id,ev = uuid,id\n        assert(tonumber(id) and isEvent(ev),\"Bad argument to postRemote\")\n        ev._from,ev._time = plugin.mainDeviceId,os.time()\n        fibaro.call(id,'RECIEVE_EVENT',{type='EVENT',ev=ev}) -- We need this as the system converts \"99\" to 99 and other \"helpful\" conversions\n      else\n        -- post to slave box in the future\n      end\n    end\n    \n    return self\n  end -- createEventEngine\n  \n  local function quickVarEvent(d,_,post)\n    local old={}; for _,v in ipairs(d.oldValue) do old[v.name] = v.value end\n    for _,v in ipairs(d.newValue) do\n      if not equal(v.value,old[v.name]) then\n        post({type='quickvar', id=d.id, name=v.name, value=v.value, old=old[v.name]})\n      end\n    end\n  end\n  \n  -- There are more, but these are what I seen so far...\n  \n  local EventTypes = {\n    AlarmPartitionArmedEvent = function(d,_,post) post({type='alarm', property='armed', id = d.partitionId, value=d.armed}) end,\n    AlarmPartitionBreachedEvent = function(d,_,post) post({type='alarm', property='breached', id = d.partitionId, value=d.breached}) end,\n    AlarmPartitionModifiedEvent = function(d,_,post) print(json.encode(d)) end,\n    HomeArmStateChangedEvent = function(d,_,post) post({type='alarm', property='homeArmed', value=d.newValue}) end,\n    HomeDisarmStateChangedEvent = function(d,_,post) post({type='alarm', property='homeArmed', value=not d.newValue}) end,\n    HomeBreachedEvent = function(d,_,post) post({type='alarm', property='homeBreached', value=d.breached}) end,\n    WeatherChangedEvent = function(d,_,post) post({type='weather',property=d.change, value=d.newValue, old=d.oldValue}) end,\n    GlobalVariableChangedEvent = function(d,_,post) post({type='global-variable', name=d.variableName, value=d.newValue, old=d.oldValue}) end,\n    GlobalVariableAddedEvent = function(d,_,post) post({type='global-variable', name=d.variableName, value=d.value, old=nil}) end,\n    DevicePropertyUpdatedEvent = function(d,_,post)\n      if d.property=='quickAppVariables' then quickVarEvent(d,_,post)\n      else\n        post({type='device', id=d.id, property=d.property, value=d.newValue, old=d.oldValue})\n      end\n    end,\n    CentralSceneEvent = function(d,_,post)\n      d.id,d.icon = d.id or d.deviceId,nil\n      post({type='device', property='centralSceneEvent', id=d.id, value={keyId=d.keyId, keyAttribute=d.keyAttribute}})\n    end,\n    SceneActivationEvent = function(d,_,post)\n      d.id = d.id or d.deviceId\n      post({type='device', property='sceneActivationEvent', id=d.id, value={sceneId=d.sceneId}})\n    end,\n    AccessControlEvent = function(d,_,post)\n      post({type='device', property='accessControlEvent', id=d.id, value=d})\n    end,\n    CustomEvent = function(d,_,post)\n      local value = api.get(\"\/customEvents\/\"..d.name)\n      post({type='custom-event', name=d.name, value=value and value.userDescription})\n    end,\n    PluginChangedViewEvent = function(d,_,post) post({type='PluginChangedViewEvent', value=d}) end,\n    WizardStepStateChangedEvent = function(d,_,post) post({type='WizardStepStateChangedEvent', value=d})  end,\n    UpdateReadyEvent = function(d,_,post) post({type='updateReadyEvent', value=d}) end,\n    DeviceRemovedEvent = function(d,_,post)  post({type='deviceEvent', id=d.id, value='removed'}) end,\n    DeviceChangedRoomEvent = function(d,_,post)  post({type='deviceEvent', id=d.id, value='changedRoom'}) end,\n    DeviceCreatedEvent = function(d,_,post)  post({type='deviceEvent', id=d.id, value='created'}) end,\n    DeviceModifiedEvent = function(d,_,post) post({type='deviceEvent', id=d.id, value='modified'}) end,\n    PluginProcessCrashedEvent = function(d,_,post) post({type='deviceEvent', id=d.deviceId, value='crashed', error=d.error}) end,\n    SceneStartedEvent = function(d,_,post)   post({type='sceneEvent', id=d.id, value='started'}) end,\n    SceneFinishedEvent = function(d,_,post)  post({type='sceneEvent', id=d.id, value='finished'})end,\n    SceneRunningInstancesEvent = function(d,_,post) post({type='sceneEvent', id=d.id, value='instance', instance=d}) end,\n    SceneRemovedEvent = function(d,_,post)  post({type='sceneEvent', id=d.id, value='removed'}) end,\n    SceneModifiedEvent = function(d,_,post)  post({type='sceneEvent', id=d.id, value='modified'}) end,\n    SceneCreatedEvent = function(d,_,post)  post({type='sceneEvent', id=d.id, value='created'}) end,\n    OnlineStatusUpdatedEvent = function(d,_,post) post({type='onlineEvent', value=d.online}) end,\n    ActiveProfileChangedEvent = function(d,_,post)\n      post({type='profile',property='activeProfile',value=d.newActiveProfile, old=d.oldActiveProfile})\n    end,\n    ClimateZoneChangedEvent = function(d,_,post) --ClimateZoneChangedEvent\n      if d.changes and type(d.changes)=='table' then\n        for _,c in ipairs(d.changes) do\n          c.type,c.id='ClimateZone',d.id\n          post(c)\n        end\n      end\n    end,\n    ClimateZoneSetpointChangedEvent = function(d,_,post) d.type = 'ClimateZoneSetpoint' post(d,_,post) end,\n    NotificationCreatedEvent = function(d,_,post) post({type='notification', id=d.id, value='created'}) end,\n    NotificationRemovedEvent = function(d,_,post) post({type='notification', id=d.id, value='removed'}) end,\n    NotificationUpdatedEvent = function(d,_,post) post({type='notification', id=d.id, value='updated'}) end,\n    RoomCreatedEvent = function(d,_,post) post({type='room', id=d.id, value='created'}) end,\n    RoomRemovedEvent = function(d,_,post) post({type='room', id=d.id, value='removed'}) end,\n    RoomModifiedEvent = function(d,_,post) post({type='room', id=d.id, value='modified'}) end,\n    SectionCreatedEvent = function(d,_,post) post({type='section', id=d.id, value='created'}) end,\n    SectionRemovedEvent = function(d,_,post) post({type='section', id=d.id, value='removed'}) end,\n    SectionModifiedEvent = function(d,_,post) post({type='section', id=d.id, value='modified'}) end,\n    QuickAppFilesChangedEvent = function(_) end,\n    ZwaveDeviceParametersChangedEvent = function(_) end,\n    ZwaveNodeAddedEvent = function(_) end,\n    RefreshRequiredEvent = function(_) end,\n    DeviceFirmwareUpdateEvent = function(_) end,\n    GeofenceEvent = function(d,_,post) post({type='location',id=d.userId,property=d.locationId,value=d.geofenceAction,timestamp=d.timestamp}) end,\n    DeviceActionRanEvent = function(d,e,post)\n      if e.sourceType=='user' then\n        post({type='user',id=e.sourceId,value='action',data=d})\n      elseif e.sourceType=='system' then\n        post({type='system',value='action',data=d})\n      end\n    end,\n  }\n  \n  local aEventEngine = nil\n  class 'SourceTrigger'\n  function SourceTrigger:__init()\n    self.refresh = RefreshStateSubscriber()\n    self.eventEngine = createEventEngine()\n    aEventEngine = self.eventEngine\n    local function post(event,firingTime)\n      setmetatable(event,eventMT)\n      if debugFlags.sourceTrigger then fibaro.trace(__TAG,fmt(\"SourceTrigger: %s\",tostring(event) \/\/ fibaro.settings.truncLog)) end\n      self.eventEngine.handleEvent(event,firingTime)\n    end\n    local function filter(ev)\n      if debugFlags.refreshEvents then\n        fibaro.trace(__TAG,fmt(\"RefreshEvent: %s:%s\",ev.type,encode(ev.data)) \/\/ fibaro.settings.truncLog)\n      end\n      return true\n    end\n    local function handler(ev)\n      if EventTypes[ev.type] then\n        EventTypes[ev.type](ev.data,ev,post)\n      end\n    end\n    self.refresh:subscribe(filter,handler)\n  end\n  function SourceTrigger:run() self.refresh:run() end\n  function SourceTrigger:subscribe(event,handler) --> subscription\n    return self.eventEngine.addEventHandler(event,handler)\n  end\n  function SourceTrigger:unsubscribe(subscription)\n    self.eventEngine.removeEventHandler(subscription)\n  end\n  function SourceTrigger:enableSubscription(subscription)\n    subscription.enable()\n  end\n  function SourceTrigger:disableSubscription(subscription)\n    subscription.disable()\n  end\n  function SourceTrigger:post(event,time,log,hook,customLog)\n    return self.eventEngine.post(event,time,log,hook,customLog)\n  end\n  function SourceTrigger:registerCallback(fun)\n    return self.eventEngine.registerCallback(fun)\n  end\n  function SourceTrigger:cancel(ref)\n    return self.eventEngine.cancel(ref)\n  end\n  function SourceTrigger:postRemote(id,event)\n    return self.eventEngine.postRemote(id,event)\n  end\n  \n  --------------------- Pub\/Sub ---------------------\n  do\n    local debugFlags = fibaro.debugFlags\n    local SUB_VAR = \"TPUBSUB\"\n    local idSubs = {}\n    local function DEBUG(...) if debugFlags.pubsub then fibaro.debug(__TAG,fmt(...)) end end\n    local inited,initPubSub,match,compile\n    local member,equal,copy = table.member,table.equal,table.copy\n    \n    function fibaro.publish(event)\n      if not inited then initPubSub(quickApp) end\n      assert(type(event)=='table' and event.type,\"Not an event\")\n      local subs = idSubs[event.type] or {}\n      for _,e in ipairs(subs) do\n        if match(e.pattern,event) then\n          for id,_ in pairs(e.ids) do\n            DEBUG(\"Sending sub QA:%s\",id)\n            fibaro.call(id,\"SUBSCRIPTION\",event)\n          end\n        end\n      end\n    end\n    \n    function fibaro.subscribe(events,handler)\n      if not inited then initPubSub(quickApp) end\n      if not events[1] then events = {events} end\n      local subs = quickApp:getVariable(SUB_VAR)\n      if subs == \"\" then subs = {} end\n      for _,e in ipairs(events) do\n        assert(type(e)=='table' and e.type,\"Not an event\")\n        if not member(e,subs) then subs[#subs+1]=e end\n      end\n      DEBUG(\"Setting subscription\")\n      quickApp:setVariable(SUB_VAR,subs)\n      if handler then\n        fibaro.event(events,handler)\n      end\n    end\n    \n    --  idSubs = {\n    --    <type> = { { ids = {... }, event=..., pattern = ... }, ... }\n    --  }\n    \n    function match(...) return aEventEngine.match(...) end\n    function compile(...) return aEventEngine.compilePattern(...) end\n    \n    function QuickApp.SUBSCRIPTION(_,e)\n      fibaro.post(e)\n    end\n    \n    local function updateSubscriber(id,events)\n      if not idSubs[id] then DEBUG(\"New subscriber, QA:%s\",id) end\n      for _,ev in ipairs(events) do\n        local subs = idSubs[ev.type] or {}\n        for _,s in ipairs(subs) do s.ids[id]=nil end\n      end\n      for _,ev in ipairs(events) do\n        local subs = idSubs[ev.type]\n        if subs == nil then\n          subs = {}\n          idSubs[ev.type]=subs\n        end\n        for _,e in ipairs(subs) do\n          if equal(ev,e.event) then\n            e.ids[id]=true\n            goto nxt\n          end\n        end\n        subs[#subs+1] = { ids={[id]=true}, event=copy(ev), pattern=compile(ev) }\n        ::nxt::\n      end\n    end\n    \n    local function checkVars(id,vars)\n      for _,var in ipairs(vars or {}) do\n        if var.name==SUB_VAR then return updateSubscriber(id,var.value) end\n      end\n    end\n    \n    function initPubSub(quickApp)\n      -- At startup, check all QAs for subscriptions\n      for _,d in ipairs(api.get(\"\/devices?interface=quickApp\") or {}) do\n        checkVars(d.id,d.properties.quickAppVariables)\n      end\n      \n      fibaro.event({type='quickvar',name=SUB_VAR},            -- If some QA changes subscription\n      function(env)\n        local id = env.event.id\n        DEBUG(\"QA:%s updated quickvar sub\",id)\n        updateSubscriber(id,env.event.value)                  -- update\n      end)\n      \n      fibaro.event({type='deviceEvent',value='removed'},      -- If some QA is removed\n      function(env)\n        local id = env.event.id\n        if id ~= quickApp.id then\n          DEBUG(\"QA:%s removed\",id)\n          updateSubscriber(env.event.id,{})                   -- update\n        end\n      end)\n      \n      local fun = function(env)                                           -- update\n        local id = env.event.id\n        if id ~= quickApp.id then\n          DEBUG(\"QA:%s created\/modified\",id)\n          checkVars(id,api.get(\"\/devices\/\"..id).properties.quickAppVariables)\n        end\n      end\n      fibaro.event({type='deviceEvent',value='created'},fun)                 -- If some QA is added or modified\n      fibaro.event({type='deviceEvent',value='modified'},fun)\n    end\n  end\n  \n  ------------ Child support --------------\n  do\n    local childID = 'ChildID'\n    local classID = 'ClassName'\n    local defChildren\n    \n    local children = {}\n    local undefinedChildren = {}\n    local createChild = QuickApp.createChildDevice\n    class 'QwikAppChild'(QuickAppChild)\n    \n    local function setupUIhandler(self)\n      if not self.UIHandler then\n        function self:UIHandler(event)\n          local obj = self\n          if self.id ~= event.deviceId then obj = (self.childDevices or {})[event.deviceId] end\n          if not obj then return end\n          local elm,etyp = event.elementName, event.eventType\n          local cb = obj.uiCallbacks or {}\n          if obj[elm] then return obj:callAction(elm, event) end\n          if cb[elm] and cb[elm][etyp] and obj[cb[elm][etyp]] then return obj:callAction(cb[elm][etyp], event) end\n          if obj[elm..\"Clicked\"] then return obj:callAction(elm..\"Clicked\", event) end\n          self:warning(\"UI callback for element:\", elm, \" not found-\")\n        end\n      end\n    end\n    \n    local function member(k,tab) for i,v in ipairs(tab) do if v==k then return i end end return false end\n    \n    function QwikAppChild:__init(device) \n      ---@diagnostic disable-next-line: undefined-field\n      QuickAppChild.__init(self, device)\n      self:debug(\"Instantiating object \",device.name)\n      local uid = self:getVariable(childID) or \"\"\n      if defChildren[uid] then\n        children[uid]=self               -- Keep table with all children indexed by uid. uid is unique.\n      else                               -- If uid not in our children table, we will remove this child\n        undefinedChildren[#undefinedChildren+1]=self.id \n      end\n    end\n    \n    local function getVar(child,varName)\n      for _,v in ipairs(child.properties.quickAppVariables or {}) do\n        if v.name==varName then return v.value end\n      end\n      return \"\"\n    end\n    \n    local function setVar(qvl,name,value)\n      qvl[#qvl+1]={name=name,value=value}\n      return qvl\n    end\n    \n    local function setupCallbacks(child)\n      local uic = getVar(child,'uiCallbacks')\n      local map = {}\n      child.uiCallbacks = map\n      if type(uic)=='table' then\n        for _,u in ipairs(uic) do\n          map[u.name] = { [u.eventType] = u.callback }\n        end\n      end\n    end\n    \n    function QuickApp:createChildDevice(uid,props,interfaces,className)\n      __assert_type(uid,'string')\n      __assert_type(className,'string')\n      props.initialProperties = props.initialProperties or {}\n      local qvars = props.quickVars or {}\n      qvars = setVar(qvars,childID,uid)\n      qvars = setVar(qvars,classID,className)\n      local callbacks = props.initialProperties.uiCallbacks\n      if callbacks then\n        qvars =  setVar(qvars,'uiCallbacks',callbacks)\n      end\n      props.initialProperties.quickAppVariables = qvars\n      props.initialInterfaces = interfaces or {}\n      if props.initialProperties.viewLayout then\n        if not member('quickApp',props.initialInterfaces) then\n          table.insert(props.initialInterfaces,'quickApp')\n        end\n      end\n      self:debug(\"Creating device \",props.name)\n      local c = createChild(self,props,_G[className])\n      if c and callbacks then\n        c:updateProperty(\"uiCallbacks\",callbacks)\n      end\n      if c and member('quickApp',props.initialInterfaces) then\n        local file = {isMain=true,type='lua',isOpen=false,name='main',content=\"\"}\n        api.put(\"\/quickApp\/\"..c.id..\"\/files\/main\",file) \n      end\n      setupCallbacks(c)\n    end\n    \n    function QuickApp:loadExistingChildren(chs)\n      __assert_type(chs,'table')\n      local stat,err = pcall(function()\n        defChildren = chs\n        self.children = children\n        function self.initChildDevices() end\n        local cdevs,n = api.get(\"\/devices?parentId=\"..self.id) or {},0 -- Pick up all my children\n        for _,child in ipairs(cdevs) do\n          local uid = getVar(child,childID)\n          local className = getVar(child,classID)\n          local childObject = _G[className] and _G[className](child) or QuickAppChild(child)\n          self.childDevices[child.id]=childObject\n          childObject.parent = self\n          setupCallbacks(childObject)\n        end\n      end)\n      if not stat then self:error(\"loadExistingChildren:\"..err) end\n    end\n    \n    function QuickApp:createMissingChildren()\n      local stat,err = pcall(function()\n        local chs = {}\n        for uid,data in pairs(defChildren) do chs[#chs+1]={uid=uid,data=data} end\n        table.sort(chs,function(a,b) return a.uid<b.uid end)\n        for _,ch in ipairs(chs) do\n          if not self.children[ch.uid] then\n            local props = {\n              name = ch.data.name,\n              type = ch.data.type,\n              initialProperties = ch.data.properties or {},\n            }\n            if ch.data.UI then\n              ---@diagnostic disable-next-line: undefined-field\n              assert(type(fibaro.UI)=='table',\"Please install fibaro.UI extension\")\n              local viewLayout,uiCallbacks = fibaro.UI.createUI(ch.data.UI)\n              props.initialProperties.viewLayout = viewLayout\n              props.initialProperties.uiCallbacks = uiCallbacks\n            end\n            self:createChildDevice(ch.uid,props,ch.data.interfaces,ch.data.className)\n          end\n        end \n      end)\n      if not stat then self:error(\"createMissingChildren:\"..err) end\n    end\n    \n    function QuickApp:removeUndefinedChildren()\n      for _,deviceId in ipairs(undefinedChildren) do -- Remove children not in children table\n        self:removeChildDevice(deviceId)\n      end\n    end\n    \n    function QuickApp:initChildren(children)\n      setupUIhandler(self)\n      self:loadExistingChildren(children)\n      self:createMissingChildren()\n      self:removeUndefinedChildren()\n    end\n  end\n  ----------- QuickApp Startup -----------\n  -- local _init,_onInit = QuickApp.__init,nil\n  \n  function QuickApp:setVersion(model,serial,version)\n    local m = model..\":\"..serial..\"\/\"..version\n    if __fibaro_get_device_property(self.id,'model') ~= m then\n      quickApp:updateProperty('model',m)\n    end\n  end\n  -- local function initQA(selfv)\n  --   local dev = __fibaro_get_device(selfv.id)\n  --   if not dev.enabled then\n  --     if fibaro.__disabled then pcall(fibaro.__disabled,selfv) end -- Hook if you want to do something when your QA is disabled\n  --     selfv:debug(\"QA \",selfv.name,\" disabled\")\n  --   else\n  --     quickApp = selfv\n  --     if _onInit then _onInit(selfv) end\n  --   end\n  -- end\n  \n  -- function QuickApp.__init(self,...) -- We hijack the __init methods so we can control users :onInit() method\n  --   _onInit = self.onInit\n  --   self.onInit = initQA\n  --   _init(self,...)\n  -- end\n  \n  -----\n  local allowed_read_exceptions={\n    module=true, -- used in socket library\n    fibaro=true,\n    hub=true,\n    loadstring=true, -- used in json lua library\n    rawset=true,\n    quickApp=true,\n  }\n  local allowed_write_exceptions = {\n    fibaro=true,\n    hub=true,\n    sourceTrigger=true,\n    clearTimeout=true,\n    setTimeout=true,\n    setInterval=true,\n    clearInterval=true,\n    onAction=true,\n    onUIEvent=true,\n    configure=true,\n    net=true,\n    api=true,\n    HomeCenter=true,\n    QuickApp=true,\n    quickApp=true,\n    json=true,\n    split=true,\n    __convertToString=true,\n    __assert_type=true,\n    __fibaro_get_device=true,\n    __fibaro_get_devices=true,\n    __fibaro_get_room=true,\n    __fibaro_get_scene=true,\n    __fibaro_get_global_variable=true,\n    __fibaro_get_device_property=true,\n    __fibaro_get_partition=true,\n    __fibaroUseAsyncHandler=true,\n    __fibaro_add_debug_message=true,\n    __ternary=true,\n    __TAG=true,\n    urlencode=true, -- HC2 has it, but HC3 doesn't.\n    FIBAROAPIHC3_VERSION=true,\n  }\n  \n  local oldClass = class\n  function class(name,...) -- declare classes read\/write\n    allowed_read_exceptions[name]=true\n    allowed_write_exceptions[name]=true\n    return oldClass(name,...)\n  end\n  \n  function fibaro.declareReadVar(name) allowed_read_exceptions[name]=true end\n  function fibaro.declareWriteVar(name) allowed_write_exceptions[name]=true end\n  \n  local function getErrLine(n)\n    local _,err = pcall(function()\n      error(\"dummy\",n+1)\n    end)\n    local f,l = err:match(\"\/([^\/]-):(%d+):\")\n    if l then return f,l else return \"<unknown>\",\"<unknown>\" end\n  end\n  local fmt = string.format\n  function fibaro.setupVariableCheck(warn)\n    local GMT,err={},error\n    for k,v in pairs(_G) do GMT[k]=v end -- copy of _G\n    setmetatable(_G, {\n      __newindex = function (t, k, v)\n        if allowed_write_exceptions[k] then\n          GMT[k]=v\n        else\n          if not warn then \n            err(\"attempt to write to undeclared variable \"..k, 2)\n          else\n            local f,el = getErrLine(4)\n            fibaro.warning(__TAG,fmt(\"attempt to write to undeclared variable '%s' at %s line %s\",k,f,el))\n            GMT[k]=v\n          end\n        end\n      end,\n      __index = function (_, k)\n        if k == '_G' then return GMT end\n        if allowed_read_exceptions[k] == nil then\n          if not warn then\n            err(\"attempt to read undeclared variable \"..k, 2)\n          else\n            local f,el = getErrLine(4)\n            fibaro.warning(__TAG,fmt(\"attempt to read undeclared variable '%s' at %s line %s\",k,f,el))\n            return GMT[k]\n          end\n        end\n        return GMT[k]\n      end,\n    })\n  end\n  ------------- Exports --------------\n  fibaro.toTime,fibaro.midnight,fibaro.getWeekNumber,fibaro.now = lib.toTime,lib.midnight,lib.getWeekNumber,lib.now","isMain":false},{"isOpen":false,"type":"lua","name":"fiblib","content":"------------- Debug ---------------------\n\nfunction fibaro.debugf(tag,fmt,...) fibaro.debug(tag,string.format(fmt,...)) end\nfunction fibaro.tracef(tag,fmt,...) fibaro.trace(tag,string.format(fmt,...)) end\nfunction fibaro.warningf(tag,fmt,...) fibaro.warning(tag,string.format(fmt,...)) end\nfunction fibaro.errorf(tag,fmt,...) fibaro.error(tag,string.format(fmt,...)) end\n\n------------- Scenes ---------------------\nfunction fibaro.isSceneEnabled(sceneID) \n  __assert_type(sceneID,\"number\" )\n  return (api.get(\"\/scenes\/\"..sceneID) or { enabled=false }).enabled \nend\n\nfunction fibaro.setSceneEnabled(sceneID,enabled) \n  __assert_type(sceneID,\"number\" )   __assert_type(enabled,\"boolean\" )\n  return api.put(\"\/scenes\/\"..sceneID,{enabled=enabled}) \nend\n\nfunction fibaro.getSceneRunConfig(sceneID)\n  __assert_type(sceneID,\"number\" )\n  return api.get(\"\/scenes\/\"..sceneID).mode \nend\n\nfunction fibaro.setSceneRunConfig(sceneID,runConfig)\n  __assert_type(sceneID,\"number\" )\n  assert(({automatic=true,manual=true})[runConfig],\"runconfig must be 'automatic' or 'manual'\")\n  return api.put(\"\/scenes\/\"..sceneID, {mode = runConfig}) \nend\n\nfunction fibaro.getSceneByName(name)\n  __assert_type(name,\"string\" )\n  for _,s in ipairs(api.get(\"\/scenes\")) do\n    if s.name==name then return s end\n  end\nend\n\n------------- Global Variables ---------------------\nfunction fibaro.getAllGlobalVariables() \n  return table.map(function(v) return v.name end,api.get(\"\/globalVariables\")) \nend\n\nfunction fibaro.createGlobalVariable(name,value,options)\n  __assert_type(name,\"string\")\n  if not fibaro.existGlobalVariable(name) then \n    value = tostring(value)\n    local args = table.copy(options or {})\n    args.name,args.value=name,value\n    return api.post(\"\/globalVariables\",args)\n  end\nend\n\nfunction fibaro.deleteGlobalVariable(name) \n  __assert_type(name,\"string\")\n  return api.delete(\"\/globalVariables\/\"..name) \nend\n\nfunction fibaro.existGlobalVariable(name)\n  __assert_type(name,\"string\")\n  return api.get(\"\/globalVariables\/\"..name) and true \nend\n\nfunction fibaro.getGlobalVariableType(name)\n  __assert_type(name,\"string\")\n  local v = api.get(\"\/globalVariables\/\"..name) or {}\n  return v.isEnum,v.readOnly\nend\n\nfunction fibaro.getGlobalVariableLastModified(name)\n  __assert_type(name,\"string\")\n  return (api.get(\"\/globalVariables\/\"..name) or {}).modified \nend\n\n------------ Custome Events ----------------------\nfunction fibaro.getAllCustomEvents() \n  return table.map(function(v) return v.name end,api.get(\"\/customEvents\") or {}) \nend\n\nfunction fibaro.createCustomEvent(name,userDescription) \n  __assert_type(name,\"string\" )\n  return api.post(\"\/customEvents\",{name=name,userDescription=userDescription or \"\"})\nend\n\nfunction fibaro.deleteCustomEvent(name) \n  __assert_type(name,\"string\" )\n  return api.delete(\"\/customEvents\/\"..name) \nend\n\nfunction fibaro.existCustomEvent(name) \n  __assert_type(name,\"string\" )\n  return api.get(\"\/customEvents\/\"..name) and true \nend\n\n----------- Profiles -------------------------------\nfunction fibaro.activeProfile(id)\n  if id then\n    if type(id)=='string' then id = fibaro.profileNameToId(id) end\n    assert(id,\"fibaro.activeProfile(id) - no such id\/name\")\n    return api.put(\"\/profiles\",{activeProfile=id}) and id\n  end\n  return api.get(\"\/profiles\").activeProfile \nend\n\nfunction fibaro.profileIdtoName(pid)\n  __assert_type(pid,\"number\")\n  for _,p in ipairs(api.get(\"\/profiles\").profiles or {}) do \n    if p.id == pid then return p.name end \n  end \nend\n\nfunction fibaro.profileNameToId(name)\n  __assert_type(name,\"string\")\n  for _,p in ipairs(api.get(\"\/profiles\").profiles or {}) do \n    if p.name == name then return p.id end \n  end \nend\n\n---------------- Partitions -----------------------\nfunction fibaro.partitionIdToName(pid)\n  __assert_type(pid,\"number\")\n  return (api.get(\"\/alarms\/v1\/partitions\/\"..pid) or {}).name \nend\n\nfunction fibaro.partitionNameToId(name)\n  assert(type(name)=='string',\"Alarm partition name not a string\")\n  for _,p in ipairs(api.get(\"\/alarms\/v1\/partitions\") or {}) do\n    if p.name == name then return p.id end\n  end\nend\n\n-- Returns devices breached in partition 'pid'\nfunction fibaro.getBreachedDevicesInPartition(pid)\n  assert(type(pid)=='number',\"Alarm partition id not a number\")\n  local p,res = api.get(\"\/alarms\/v1\/partitions\/\"..pid),{}\n  for _,d in ipairs((p or {}).devices or {}) do\n    if fibaro.getValue(d,\"value\") then res[#res+1]=d end\n  end\n  return res\nend\n\n-- helper function\nlocal function filterPartitions(filter)\n  local res = {}\n  for _,p in ipairs(api.get(\"\/alarms\/v1\/partitions\") or {}) do if filter(p) then res[#res+1]=p.id end end\n  return res\nend\n\n-- Return all partitions ids\nfunction fibaro.getAllPartitions() return filterPartitions(function() return true end) end\n\n-- Return partitions that are armed\nfunction fibaro.getArmedPartitions() return filterPartitions(function(p) return p.armed end) end\n\n-- Return partitions that are about to be armed\nfunction fibaro.getActivatedPartitions() return filterPartitions(function(p) return p.secondsToArm end) end\n\n-- Return breached partitions\nfunction fibaro.getBreachedPartitions() return api.get(\"\/alarms\/v1\/partitions\/breached\") or {} end\n\n--If you want to list all devices that can be part of a alarm partition\/zone you can do\nfunction fibaro.getAlarmDevices() return api.get(\"\/alarms\/v1\/devices\/\") end\n\nfunction fibaro.armPartition(id)\n  if id == 0 then\n    return api.post(\"\/alarms\/v1\/partitions\/actions\/arm\")\n  else\n    return api.post(\"\/alarms\/v1\/partitions\/\"..id..\"\/actions\/arm\")\n  end\nend\n\nfunction fibaro.unarmPartition(id)\n  if id == 0 then\n    return api.delete(\"\/alarms\/v1\/partitions\/actions\/arm\")\n  else\n    return api.delete(\"\/alarms\/v1\/partitions\/\"..id..\"\/actions\/arm\")\n  end\nend\n\nfunction fibaro.tryArmPartition(id)\n  local res,code\n  if id == 0 then\n    res,code = api.post(\"\/alarms\/v1\/partitions\/actions\/tryArm\")\n    if type(res) == 'table' then\n      local r = {}\n      for _,p in ipairs(res) do r[p.id]=p.breachedDevices end\n      if next(r) then return r,200 else return nil end\n    else\n      return nil\n    end\n  else\n    local res,_ = api.post(\"\/alarms\/v1\/partitions\/\"..id..\"\/actions\/tryArm\")\n    local bd = res and res.breachedDevices or {}\n    if res.result==\"armDelayed\" and #bd > 0 then return {[id]=bd},200 else return nil end\n  end\nend\n\n-------------------- Weather -------------------------------\nfibaro.weather = {}\nfunction fibaro.weather.temperature() return api.get(\"\/weather\").Temperature end\nfunction fibaro.weather.temperatureUnit() return api.get(\"\/weather\").TemperatureUnit end\nfunction fibaro.weather.humidity() return api.get(\"\/weather\").Humidity end\nfunction fibaro.weather.wind() return api.get(\"\/weather\").Wind end\nfunction fibaro.weather.weatherCondition() return api.get(\"\/weather\").WeatherCondition end\nfunction fibaro.weather.conditionCode() return api.get(\"\/weather\").ConditionCode end\n\n---------------- Climate panel ---------------------------\n--Returns mode - \"Manual\", \"Vacation\", \"Schedule\"\nfunction fibaro.getClimateMode(id)\n  return (api.get(\"\/panels\/climate\/\"..id) or {}).mode\nend\n\n--Returns the currents mode \"mode\", or sets it - \"Auto\", \"Off\", \"Cool\", \"Heat\"\nfunction fibaro.climateModeMode(id,mode)\n  if mode==nil then return api.get(\"\/panels\/climate\/\"..id).properties.mode end\n  assert(({Auto=true,Off=true,Cool=true,Heat=true})[mode],\"Bad climate mode\")\n  return api.put(\"\/panels\/climate\/\"..id,{properties={mode=mode}})\nend\n\n-- Set zone to scheduled mode\nfunction fibaro.setClimateZoneToScheduleMode(id)\n  __assert_type(id, \"number\")\n  return api.put('\/panels\/climate\/'..id, {properties = {\n    handTimestamp     = 0,\n    vacationStartTime = 0,\n    vacationEndTime   = 0\n  }})\nend\n\n-- Set zone to manual, incl. mode, time ( secs ), heat and cool temp\nfunction  fibaro.setClimateZoneToManualMode(id, mode, time, heatTemp, coolTemp)\n  __assert_type(id, \"number\") __assert_type(mode, \"string\")\n  assert(({Auto=true,Off=true,Cool=true,Heat=true})[mode],\"Bad climate mode\")\n  return api.put('\/panels\/climate\/'..id, { properties = { \n    handMode            = mode, \n    vacationStartTime   = 0, \n    vacationEndTime     = 0,\n    handTimestamp       = tonumber(time) and os.time()+time or math.tointeger(2^32-1),\n    handSetPointHeating = tonumber(heatTemp) and heatTemp or nil,\n    handSetPointCooling = tonumber(coolTemp) and coolTemp or nil\n  }})\nend\n\n-- Set zone to vacation, incl. mode, start (secs from now), stop (secs from now), heat and cool temp\nfunction fibaro.setClimateZoneToVacationMode(id, mode, start, stop, heatTemp, coolTemp)\n  __assert_type(id,\"number\") __assert_type(mode,\"string\") __assert_type(start,\"number\") __assert_type(stop,\"number\")\n  assert(({Auto=true,Off=true,Cool=true,Heat=true})[mode],\"Bad climate mode\")\n  local now = os.time()\n  return api.put('\/panels\/climate\/'..id, { properties = {\n    vacationMode            = mode,\n    handTimestamp           = 0, \n    vacationStartTime       = now+start, \n    vacationEndTime         = now+stop,\n    vacationSetPointHeating = tonumber(heatTemp) and heatTemp or nil,\n    vacationSetPointCooling = tonumber(coolTemp) and coolTemp or nil\n  }})\nend\n\n--------------------------- QuickApps ----------------------------\nfunction fibaro.restartQA(id)\n  __assert_type(id,\"number\")\n  return api.post(\"\/plugins\/restart\",{deviceId=id or plugin.mainDeviceId})\nend\n\nfunction fibaro.getQAVariable(id,name)\n  __assert_type(id,\"number\")\n  __assert_type(name,\"string\")\n  local props = (api.get(\"\/devices\/\"..(id or plugin.mainDeviceId)) or {}).properties or {}\n  for _, v in ipairs(props.quickAppVariables or {}) do\n    if v.name==name then return v.value end\n  end\nend\n\nfunction fibaro.setQAVariable(id,name,value)\n  __assert_type(id,\"number\")\n  __assert_type(name,\"string\")\n  return fibaro.call(id,\"setVariable\",name,value)\nend\n\nfunction fibaro.getAllQAVariables(id)\n  __assert_type(id,\"number\")\n  local props = (api.get(\"\/devices\/\"..(id or plugin.mainDeviceId)) or {}).properties or {}\n  local res = {}\n  for _, v in ipairs(props.quickAppVariables or {}) do\n    res[v.name]=v.value\n  end\n  return res\nend\n\nfunction fibaro.isQAEnabled(id)\n  __assert_type(id,\"number\")\n  local dev = api.get(\"\/devices\/\"..(id or plugin.mainDeviceId))\n  return (dev or {}).enabled\nend\n\nfunction fibaro.setQAValue(device, property, value)\n  fibaro.call(device, \"updateProperty\", property, (json.encode(value)))\nend\n\nfunction fibaro.enableQA(id,enable)\n  __assert_type(id,\"number\")\n  __assert_type(enable,\"boolean\")\n  return api.post(\"\/devices\/\"..(id or plugin.mainDeviceId),{enabled=enable==true})\nend\n\nfunction fibaro.deleteFile(deviceId,file)\n  local name = type(file)=='table' and file.name or file\n  return api.delete(\"\/quickApp\/\"..(deviceId or plugin.mainDeviceId)..\"\/files\/\"..name)\nend\n\nfunction fibaro.updateFile(deviceId,file,content)\n  if type(file)=='string' then\n    file = {isMain=false,type='lua',isOpen=false,name=file,content=\"\"}\n  end\n  file.content = type(content)=='string' and content or file.content\n  return api.put(\"\/quickApp\/\"..(deviceId or plugin.mainDeviceId)..\"\/files\/\"..file.name,file) \nend\n\nfunction fibaro.updateFiles(deviceId,list)\n  if #list == 0 then return true end\n  return api.put(\"\/quickApp\/\"..(deviceId or plugin.mainDeviceId)..\"\/files\",list) \nend\n\nfunction fibaro.createFile(deviceId,file,content)\n  if type(file)=='string' then\n    file = {isMain=false,type='lua',isOpen=false,name=file,content=\"\"}\n  end\n  file.content = type(content)=='string' and content or file.content\n  return api.post(\"\/quickApp\/\"..(deviceId or plugin.mainDeviceId)..\"\/files\",file) \nend\n\nfunction fibaro.getFile(deviceId,file)\n  local name = type(file)=='table' and file.name or file\n  return api.get(\"\/quickApp\/\"..(deviceId or plugin.mainDeviceId)..\"\/files\/\"..name) \nend\n\nfunction fibaro.getFiles(deviceId)\n  local res,code = api.get(\"\/quickApp\/\"..(deviceId or plugin.mainDeviceId)..\"\/files\")\n  return res or {},code\nend\n\nfunction fibaro.copyFileFromTo(fileName,deviceFrom,deviceTo)\n  deviceTo = deviceTo or plugin.mainDeviceId\n  local copyFile = fibaro.getFile(deviceFrom,fileName)\n  assert(copyFile,\"File doesn't exists\")\n  fibaro.addFileTo(copyFile.content,fileName,deviceTo)\nend\n\nfunction fibaro.addFileTo(fileContent,fileName,deviceId)\n  deviceId = deviceId or plugin.mainDeviceId\n  local file = fibaro.getFile(deviceId,fileName)\n  if not file then -- Create new file\n    local _,res = fibaro.createFile(deviceId,{   \n      name=fileName,\n      type=\"lua\",\n      isMain=false,\n      isOpen=false,\n      content=fileContent\n    })\n    if res == 200 then\n      fibaro.debug(nil,\"File '\",fileName,\"' added\")\n    else quickApp:error(\"Error:\",res) end\n  elseif file.content ~= fileContent then  -- Update existing file\n    local _,res = fibaro.updateFile(deviceId,{  \n      name=file.name,\n      type=\"lua\",\n      isMain=file.isMain,\n      isOpen=file.isOpen,\n      content=fileContent\n    })\n    if res == 200 then\n      fibaro.debug(nil,\"File '\",fileName,\"' updated\")\n    else fibaro.error(nil,\"Error:\",res) end\n  else\n    fibaro.debug(nil,\"File '\",fileName,\"' not changed\")\n  end\nend\n\nfunction fibaro.getFQA(deviceId) return api.get(\"\/quickApp\/export\/\"..deviceId) end\n\nfunction fibaro.putFQA(content) -- Should be .fqa json\n  if type(content)=='table' then content = json.encode(content) end\n  return api.post(\"\/quickApp\/\",content)\nend","isMain":false},{"isOpen":false,"type":"lua","name":"engine","content":"--[[\nOffical bughunters:\n@Sjakie\n@Neo Andersson\n@ChristianSogaard\n@Pica2017\n--]]\n\n---@diagnostic disable: undefined-global\nfibaro.__ER  = fibaro.__ER or { modules={} }\nlocal version = 1.05\nQuickApp.E_SERIAL,QuickApp.E_VERSION,QuickApp.E_FIX = \"UPD896846032517892\",version,\"N\/A\"\n\nlocal stack,stream,errorMsg,isErrorMsg,e_error,e_pcall,errorLine,\nmarshallFrom,marshallTo,toTime,midnight,encodeFast,argsStr,eventStr,\nPrintBuffer,sunData,LOG,LOGERR,htmlTable,evOpts\n\nlocal fmt = string.format\nlocal function trim(str) return str:gsub(\"^[%s%c]*(.-)[%s%c]*$\",\"%1\") end\nlocal ER = fibaro.__ER\nlocal macros = {}\n\nfunction fibaro.__ER.modules.engine(ER)\n  local Script = ER.Script\n  local fmt= string.format\n  local debugf = ER.debug\n  \n  local function createProps(getProps,setProps,helpers)\n    ER.definePropClass('StdPropObject')\n    ER.propHelpers = helpers\n    function StdPropObject:__init(id)\n      PropObject.__init(self)\n      self.id = id\n      --setmetatable(self,{__tostring = function(t) return \"device:\"..tostring(self.id) end})\n    end\n    function StdPropObject:__tostring() return \"device:\"..tostring(self.id) end\n    for gp,map in pairs(getProps) do\n      local m = map\n      StdPropObject.getProp[gp] = function(id,prop,event) return m[2](id.id,m[3],event)  end-- fun(id,prop,event)\n      if m[5] then\n        StdPropObject.trigger[gp] = function(self,id,gp) return {type=m[1], id=id, property=m[3]} end\n      else StdPropObject.trigger[gp] = true end\n      if m[4] then StdPropObject.map[gp] = m[4] end\n    end\n    for gp,map in pairs(setProps) do\n      local m = map\n      local sf,cmd = m[1],m[2]\n      StdPropObject.setProp[gp] = function(id,prop,val) return sf(id.id,cmd,val) end\n    end\n    local stdPropObject = StdPropObject()\n    ER.stdPropObject = stdPropObject\n    \n    ER.addStdPropFuns()\n  end\n  \n  ------- Rule variables -----------------------------------\n  local vars,triggerVars = ER.vars,ER.triggerVars\n  local reverseVarTable = {}\n  function ER.defVar(name,init) vars[name] = init end\n  function ER.defTriggerVar(name,init) triggerVars[name] = init end\n  function ER.defvars(tab) for var,val in pairs(tab) do ER.defVar(var,val) end end\n  function ER.reverseMapDef(table) ER._reverseMap({},table) end\n  function ER._reverseMap(path,value)\n    if type(value) == 'number' then reverseVarTable[tostring(value)] = table.concat(path,\".\")\n    elseif type(value) == 'table' and not value[1] then\n      for k,v in pairs(value) do table.insert(path,k); ER._reverseMap(path,v); table.remove(path) end\n    end\n  end\n  function ER.reverseVar(id) return reverseVarTable[tostring(id)] or id end\n  \n  ----------------------------------------------------------------------------------\n  -- Runnning a corutine with ER \"behaviour\" - waits, callbacks etc.\n  -- options = { success = function(success,...), error = function(err), suspended = function(success,...), trace = bool }\n  local function runCoroutine(co,options,...)\n    options = options or co.options\n    local coroutine = ER.coroutine\n    local function runner(...)\n      local stat = {coroutine.resume(co,...)}\n      if not stat[1] then\n        return options.error(stat[2])\n      else\n        if coroutine.status(co)=='suspended' then\n          options.suspended(table.unpack(stat,2))\n          local action = stat[2]\n          if action == '%wait%' then\n            Script.setTimeout(co.rtd,runner,stat[3])\n            local msg = stat[4] or stat[2]\n            return false,msg\n          end -- ignore 'callback'\n          return false,table.unpack(stat,2)\n        else\n          options.success(table.unpack(stat,2))\n          return true,table.unpack(stat,2)\n        end\n        \n      end\n    end\n    co.options = options\n    co.rtd.trace = options.trace\n    co.rtd.co = co\n    return runner(...)\n  end\n  ER.runCoroutine = runCoroutine\n  \n  local function eval(str,options) -- Evaluate rule and run coroutine\n    assert(type(str)=='string',\"first argument to eval must be a string (eventscript)\")\n    local str2 = str:gsub(\"(\\xC2\\xA0)\",\"<*>\")\n    if str2 ~= str and not ER.settings.ignoreInvisibleChars then\n      error(\"String contains illegal chars: \"..str2)\n    end\n    str = trim(str)\n    local coroutine = ER.coroutine\n    options = options or {}\n    options.src = str\n    local stat,tkns = pcall(ER.tokenize,ER,str)\n    if not stat then\n      error(fmt(\"Token error in string '%s'\\n%s\",str,tkns))\n    end\n    local defRule =  tkns.containsOp('rule')\n    if defRule then\n      local rule = ER:createRuleObject(options)\n      options.rule = rule\n      --if not options.silent then LOG(\"Defining [Rule:%s:%s]...\",rule._name,rule.src \/\/ settings.truncStr) end\n    end\n    local p = ER:parse(tkns,options)\n    if options.listTree then print(json.encode(ER.simplifyParseTree(p))) end\n    local fun = ER:compile(p,options)\n    if fun == nil then error(\"can't compile \"..str) end\n    if options.listCode then print(fun.codeList()) end\n    local co = coroutine.create(fun)\n    function co._post(ev,t,descr) return fibaro.post(ev,t,descr) end\n    function co._cancelPost( ) return fibaro.cancel(ref) end\n    function co._setTimeout(fun,delay,descr) return setTimeout(fun,delay) end\n    function co._clearTimeout(ref) return clearTimeout(ref) end\n    return runCoroutine(co,options,table.unpack(options.args or {})) -- resume with handling of waits etc...\n  end\n  ER.eval = eval\n  \n  createProps(ER.setupProps())\n  \n  local er = ER.er\n  function er.defmacro(name,str) -- Simple macro functions with optional arguments\n    local pattern,params = \"([%w_]+)\",{}\n    if name:find(\"%(\") then pattern = pattern..\"(%b())\" end\n    local a,b = name:match(pattern)\n    if not a then error(\"Bad macro name\") end\n    if b then\n      params = b:sub(2,-2):split(\",\")\n    end\n    local macro =  function(code)\n      if not b then return code:gsub(a,str) end\n      code = code:gsub(a..\"(%b())\",function(args)\n        args = args:sub(2,-2):split(\",\")\n        local subs = str\n        for i,v in ipairs(params) do\n          subs = subs:gsub(\"{{\"..v..\"}}\",args[i])\n        end\n        return subs\n      end)\n      return code\n    end\n    macros[#macros+1] = macro\n  end\n  \n  local vID = 10000\n  function er.createBinaryDevice(id) \n    if not id then vID = vID + 1; id = vID end\n    local d = VirtBinarySwitch(id)\n    ER.utilities.emulatedDevices[id] = d\n    return id\n  end\n  \n  function er.createMultilevelDevice(id) \n    if not id then vID = vID + 1; id = vID end\n    local d = VirtMultilevelSwitch(id)\n    ER.utilities.emulatedDevices[id] = d\n    return id\n  end\nend -- engine module\n\nlocal function setup(ER)\n  \n  local midnightFuns = {}\n  function ER.midnightScheduler(fun) midnightFuns[#midnightFuns+1] = fun end\n  local mref = nil\n  function ER.startMidnightScheduler() \n    if mref then clearTimeout(mref) end\n    local d = os.date(\"*t\")\n    d.hour,d.min,d.sec = 24,0,0\n    local midnxt = os.time(d)\n    local function midnightLoop()\n      for _,f in ipairs(midnightFuns) do f() end\n      local d = os.date(\"*t\")\n      d.hour,d.min,d.sec = 24,0,0\n      midnxt = os.time(d)\n      mref = setTimeout(midnightLoop,(midnxt-os.time())*1000)\n    end\n    mref = setTimeout(midnightLoop,(midnxt-os.time())*1000)\n  end\n  ER.startMidnightScheduler()\n  \n  class 'PropObject'\n  local ftype = 'func'..'tion' -- fool the autoindetation...\n  \n  function ER.isPropObject(o) return type(o)=='userdata' and o.__type == '%PropObject%' end\n  function PropObject:__init()\n    self.__type = '%PropObject%'\n    -- self.getProp = self.getProp or {}\n    -- self.setProp = self.setProp or {}\n    -- self.trigger = self.trigger or {}\n    self.__str=\"PropObject:\"..tostring({}):match(\"(%d.*)\")\n  end\n  function PropObject:isProp(prop) return self.getProp[prop] or self.setProp[prop] end\n  function PropObject:isTrigger(prop) return self.trigger[prop] end\n  function PropObject:getTrigger(id,prop)\n    local t = self.trigger[prop]\n    return t and type(t) == ftype and t(self,id,prop) or type(t) == 'table' or nil\n  end\n  function PropObject:__tostring() return self.__str end\n  \n  ER.PropObject = PropObject\n  function ER.definePropClass(name)\n    class(name)(PropObject)\n    local cl = _G[name]\n    cl.getProp,cl.setProp,cl.trigger,cl.map={},{},{},{}\n  end\n  \n  class 'VirtDevice'\n  function VirtDevice:__init(id) self.id = id self.modified=os.time() end\n  function VirtDevice:call(method,...)\n    local args = {...}\n    if method=='turnOn' then self:turnOn() self:stateChange('state',true)\n    elseif method=='turnOff' then self:turnOff() self:stateChange('state',false)\n    elseif method=='setValue' then self:setValue(args[1])\n    elseif method=='updateProperty' then self:updateProperty(args[1],args[2])\n    else error(\"Unknown method \"..method) end\n  end\n  function VirtDevice:turnOn() self:stateChange('value',true) end\n  function VirtDevice:turnOff() self:stateChange('value',false) end\n  function VirtDevice:setValue(value) self:stateChange('value',value) end\n  function VirtDevice:updateProperty(prop,value) self:stateChange(prop,value) end\n  function VirtDevice:__tostring() return self._name..tostring(self.id) end\n  function VirtDevice:stateChange(prop,value)\n    local old = self.props[prop]\n    self.props[prop] = value\n    if old ~= value then self.modified=os.time(); fibaro.post({type='device',id=self.id,property=prop,value=value,old=old}) end\n  end\n  function VirtDevice:get(prop) return self.props[prop] end\n  \n  class 'VirtBinarySwitch'(VirtDevice)\n  function VirtBinarySwitch:__init(id) \n    VirtDevice.__init(self,id) self.props = {value=false,state=false} \n    self._name = \"VirtBinaryDevice\"\n  end\n  class 'VirtMultilevelSwitch'(VirtDevice)\n  function VirtMultilevelSwitch:__init(id) \n    VirtDevice.__init(self,id) self.props = {value=0,state=false} \n    self._name = \"VirtMultilevelDevice\"\n  end\n  function VirtMultilevelSwitch:turnOn() self:stateChange('value',99) self:stateChange('state',true) end\n  function VirtMultilevelSwitch:turnOff() self:stateChange('value',0) self:stateChange('state',true) end\nend -- setup\n\nfunction QuickApp:eval(str) -- Terminal eval function\n  str = trim(str)\n  local e_pcall = ER.utilities.e_pcall\n  local opt = {}\n  if str==\"\" then return end\n  local r,o = str:match(\"(.*)\/\/\/(.*)\")\n  if r then\n    local stat,err = e_pcall(function()\n      opt = ER.er.eval(o,{silent=true})\n    end)\n    if type(opt)~='table' or not stat then self:error(\"\/\/\/option\",err) end\n    str=r\n  end\n  local stat,err = (e_pcall or pcall)(function()\n    ER.er.eval(str,opt)\n  end)\n  err = tostring(err)\n  err = err:gsub(\"\\n\",\"<\/br>\")\n  err = err:gsub(\" \",\"&nbsp;\")\n  if not stat then self:error(err) end\nend\n\n----------------------------------------------------------------------------------\n-- Setup engine and call main function\nlocal EventRunnerEngineCont\nfunction QuickApp:EventRunnerEngine(callback)\n  self:debug(\"Initializing EventRunner5...\")\n  function self.initChildDevices() end\n  local session = math.random(1000000)\n  self:internalStorageSet('Session',session)\n  setTimeout(function()\n    if self:internalStorageGet('Session') ~= session then\n      self:warning(\"Duplicate QA instance - disabling QA\")\n      if fibaro.doppelganger then fibaro.doppelganger() end\n      fibaro.sleep(500)\n      self:setEnabled(false)\n      plugin.restart()\n    else\n      self:debug(\"EventRunner5 initialized\")\n      setInterval(function()\n        self:internalStorageSet('Session',session)\n      end, 2*10000)\n      EventRunnerEngineCont(self,callback)\n    end\n  end,3*1000*(fibaro.fibemu and 0 or 1))\nend\nfunction EventRunnerEngineCont(self,callback)\n  quickApp = self\n  local dev = __fibaro_get_device(self.id)\n  if not dev.enabled then self:debug(\"QA disabled\"); return end\n  self:setVersion(\"EventRunner5\",self.E_SERIAL,self.E_VERSION)\n  self:updateView('title','text',fmt(\"EventRunner5 v%0.3f\",self.E_VERSION))\n  local vp = api.get(\"\/settings\/info\").currentVersion.version\n  local a,b,c = vp:match(\"(%d+)%.(%d+)%.(%d+)\")\n  vp = tonumber(string.format(\"%03d%03d%03d\",a,b,c))\n  if vp < 5142083 then\n    self:error(\"Sorry, EventRunner5 only works with FW v5.142.83 or later\")\n    return\n  end\n  \n  local st = SourceTrigger()\n  function fibaro.post(event,time,logStr,hook,customLog) return st:post(event,time,logStr,hook,customLog) end \n  function fibaro.event(event,fun) return st:subscribe(event,fun) end\n  function fibaro.removeEvent(event) return st:unsubscribe(event) end\n  function fibaro.cancel(ref) clearTimeout(ref) end\n  function fibaro.registerSourceTriggerCallback(fun) return st:registerCallback(fun) end\n  function fibaro.postRemote(id,event) return st:postRemote(id,event) end\n  st:run()\n  \n  fibaro.debugFlags.html = true\n  fibaro.debugFlags.onaction=false\n  \n  local er = {}\n  ER.settings = fibaro.settings or {}\n  ER.debug = fibaro.debugFlags or {}\n  -- Global debug flags, can be overridden by ruleOptions\n  ER.debug.ruleTrigger    = true -- log rules being triggered\n  ER.debug.ruleTrue       = true -- log rules with condition succeeding\n  ER.debug.ruleFalse      = true -- log rules with condition failing\n  ER.debug.ruleResult     = false -- log results of rules running\n  ER.debug.evalResult     = true -- log results of evaluations\n  ER.debug.post           = true -- log events being posted\n  ER.debug.sourceTrigger  = true -- log incoming sourceTriggers\n  ER.debug.refreshEvents  = true -- log incoming refreshEvents\n  \n  -- Global settings\n  ER.settings.marshall       = true          -- autoconvert globalVariables values to numbers, booleans, tables when accessed\n  ER.settings.systemLogTag   = nil           -- log tag for ER system messages, defaults to __TAG\n  ER.settings.ignoreInvisibleChars = false   -- Check code for invisible characters (xC2xA0) before evaluating\n  ER.settings.truncLog       = 100           -- truncation of log output\n  ER.settings.truncStr       = 80            -- truncation of log strings\n  ER.settings.bannerColor    = \"orange\"      -- color of banner in log, defaults to \"orange\"\n  ER.settings.listColor      = \"purple\"      -- color of list log (list rules etc), defaults to \"purple\"\n  ER.settings.statsColor     = \"green\"       -- color of statistics log, defaults to \"green\"\n  ER.settings.logFunction = function(rule,tag,str) return fibaro.debug(tag,str) end -- function to use for user log(), defaults to fibaro.debug if nil\n  ER.settings.asyncTimeout   = 10000         -- timeout for async functions, defaults to 10 seconds\n  \n  ER.er = er\n  \n  local vars = {}\n  ER._vars = vars\n  local async \n  ER.vars = setmetatable({},\n  {\n    __index = function(t,k) return k=='async' and async or vars[k] and vars[k][1] or nil end,\n    __newindex = function(t,k,v) vars[k] = {v} end\n  })\n  async = setmetatable({},{\n    __newindex = function(t,k,v) vars[k] = {er.async(v)} end\n  })\n  \n  local triggerVars = {}  -- Trigger variables are marked here.\n  class 'TVAL'\n  function TVAL:__init(value) self.__tvvalue = value end\n  ER._triggerVars = triggerVars\n  ER.triggerVars = setmetatable({},\n  {\n    __index = function(t,k) return triggerVars[k] end,\n    __newindex = function(t,k,v)\n      local trig,old = false,false\n      if type(v) == 'userdata' and v.__tvvalue then\n        v,old,trig = v.__tvvalue,ER.vars[k],true\n      end\n      triggerVars[k]=true\n      ER.vars[k]=v\n      if trig and not table.equal(old,v) then \n        fibaro.post({type='trigger-variable',name=k,value=v,old=old,_sh=true})\n      end\n    end\n  })\n  local MTasyncCallback = {\n    __call = function(cb,...)\n      if not cb[1] then error(\"async callback not asyncronous called\") end\n      if not cb[2] then cb[1](...) end\n    end\n  }\n  function ER.asyncFun(f)\n    local function afun(...)\n      local cb = setmetatable({},MTasyncCallback)\n      local delay,msg = f(cb,...)\n      return '%magic_suspend%',cb,tonumber(delay),msg\n    end\n    return afun\n  end\n  ER.builtins = {}\n  ER.builtinArgs = {}\n  ER.propFilters = {}\n  \n  local function multiLine(str)\n    if not str:find(\"\\n\") then return \"'\"..str..\"'\" end\n    return \"\\n\"..str\n  end\n  \n  function QuickApp:enableTriggerType(triggers) end\n  \n  ER.modules.utilities(ER) -- setup utilities, needed by all modules\n  stack,stream,errorMsg,isErrorMsg,e_error,e_pcall,errorLine,\n  marshallFrom,marshallTo,toTime,midnight,encodeFast,argsStr,eventStr,\n  PrintBuffer,sunData,LOG,LOGERR,htmlTable,evOpts =\n  table.unpack(ER.utilities.export)\n  \n  setup(ER)\n  \n  ER.modules.tokenizer(ER)\n  ER.modules.parser(ER)\n  ER.modules.vm(ER)\n  ER.modules.builtins(ER)\n  ER.modules.engine(ER)\n  ER.modules.rule(ER)\n  ER.modules.compiler(ER)\n  \n  ER.utilities.printBanner(\"%s, deviceId:%s, version:%s\",{self.name,self.id,self.E_VERSION})\n  local eval = ER.eval\n  \n  -- Define user functions available in main from the er.* table\n  function er.runFun(str,options) return er.compile(str,options or {})() end\n  function er.eval0(str,options) return eval(str,options or {}) end\n  function er.compile(str,options)\n    options = options or {}\n    options.src = str\n    local p = ER:parse(str,options)\n    return ER:compile(p,options)\n  end\n  \n  function er.eval(name,str,options)         -- top-level eval for expressions - used by rule(...)\n    if type(name)=='string' and type(str)=='string' then\n      options = options or {}\n      options.name = name\n    else str,options = name,str end\n    \n    for _,macro in ipairs(macros) do str = macro(str) end -- macro expand\n    \n    options = options and table.copy(options) or {}\n    for k,v in pairs(er.ruleOpts) do if options[k]==nil then options[k]=v end end\n    \n    options.error = options.error or function(err) -- setup handlers for error,suspend,success\n      LOGERR(\"%s\",err)\n      e_error(err)\n    end\n    options.suspended = options.suspended or function(...) end       -- default, do nothing\n    options.success = options.success or function(...)               -- expression succeeded - log results\n      local res = {...}\n      if #res==1 and type(res[1])=='table' and res[1].evalPrint then -- result is a table with evalPrint method\n        res[1].evalPrint(res[1],str)                                 -- let object control its own print\n      else\n        if (not options.silent) and evOpts(options.evalResult,ER.debug.evalResult) then LOG(fmt(\"%s > %s [done]\",multiLine(str),argsStr(...))) end\n      end\n    end\n    \n    local stat = {e_pcall(er.eval0,str,options)} -- This is a coroutine result; bool,bool,...\n    if stat[1] then return table.unpack(stat,3) end\n    e_error(stat[2])\n    --options.error(stat[2])\n  end\n  \n  er.runCoroutine = ER.runCoroutine\n  function er.parse(str,options) return ER:parse(str,options or {}) end\n  function er.isRule(p) return type(p)=='table' and p.type=='%RULE%' end\n  ER.isRule = er.isRule\n  er.definePropClass = ER.definePropClass\n  \n  er.variables = ER.vars\n  er.triggerVariables = ER.triggerVars\n  function er.defvar(name,init) ER.vars[name]=init end\n  \n  er.defTriggerVar = ER.defTriggerVar\n  er.deftriggervar = ER.defTriggerVar\n  er.rule = er.eval\n  er.reverseMapDef = ER.reverseMapDef\n  er.coroutine = ER.coroutine\n  er.pcall = e_pcall\n  er.xerror = e_error\n  er._utilities = ER.utilities\n  er.debug,er.settings = ER.debug,ER.settings\n  er.eventToString = ER.eventToString\n  function er.color(color,str) return \"<font color=\"..color..\">\"..str..\"<\/font>\" end\n  ER.color = er.color\n  er.ruleOpts = {}\n  er.startMidnightScheduler = ER.startMidnightScheduler\n  er.speedTime = ER.utilities.speedTime\n  er.setTime = ER.utilities.setTime\n  \n  for k,v in pairs({\n    listRules= ER.listRules,listVariables=ER.listVariables,listTimers=ER.listTimers,\n    listStats = ER.listRuleStats, stdProp = ER.stdPropObject,\n    enable=ER.enable,disable=ER.disable,\n    defvars = function(t) for k,v in pairs(t) do er.defvar(k,v) end end,\n    async = ER.asyncFun,\n  }) do er[k] = v; ER.vars[k]=v end\n  ER.vars.rule = function(i) return ER.rules[i] end\n  ER.vars.triggervar = ER.defTriggerVar\n  \n  er.Util = { \n    defTriggerVar = ER.defTriggerVar,\n    defVar = er.defvar,\n    defvars = er.defvars,\n    reverseMapDef = ER.reverseMapDef,\n  }\n  \n  for c,f in pairs(ER.constants) do ER:addInstr(c,f,\"%s\/%s\") end\n  for c,f in pairs(ER.builtins) do ER:addInstr(c,f,\"%s\/%s\") end\n  \n  local uiHandler = self.UIHandler -- Handles button presses from ER QA UI\n  function self:UIHandler(event)\n    if event.deviceId == quickApp.id then\n      fibaro.post({type='UI',cmd=event.elementName,value=event.values[1]}) -- cmd is buttonID\n    elseif uiHandler then uiHandler(self,event) end\n  end\n  \n  local uptime = os.time() - api.get(\"\/settings\/info\").serverStatus\n  local uptimeStr = fmt(\"%d days, %d hours, %d minutes\",uptime \/\/ (24*3600),(uptime % 24*3600) \/\/ 3600, (uptime % 3600) \/\/ 60)\n  ER.vars.uptimeStr = uptimeStr\n  ER.vars.uptimeMinutes = uptime \/\/ 60\n  local _mainInited = false\n  local function starter()\n    MODULES = MODULES or {}\n    for _,m in ipairs(MODULES) do -- patch modules to set _inited flags\n      local m0,l = m,m.loader\n      m.loader = function(self,er) if not m0._inited then l(self,er) end m0._inited = true end\n    end\n    local main = self.main\n    \n    if main then -- patch main to only run once\n      function self:main(er) if not _mainInited then main(self,er) _mainInited = true end end\n    end\n    if callback then callback(er) end -- this can add main and\/or run modules\n    if main and not _mainInited then  -- if we have main and not run by callback then add it to modules\n      MODULES[#MODULES+1]={name='main',prio=0,loader=self.main}\n    end\n    table.sort(MODULES,function(a,b) return a.prio < b.prio end) -- Sort modules in priority order\n    for _,m in ipairs(MODULES) do -- load modules if not already _inited\n      if not m._inited then\n        print(\"Loading rules from \",m.name)\n        m.loader(self,er)\n        m._inited = true\n      end\n    end\n    return #MODULES>=1\n  end\n  \n  LOG(\"Setting up rules...\")\n  local t0 = os.clock()\n  local stat,err = pcall(starter)\n  if not stat then\n    fibaro.error(__TAG,\"Rule setup error(s) - fix & restart...\")\n    fibaro.error(__TAG,\"Last err:\", err)\n    for i,r in pairs(ER.rules) do r.disable() end\n    return\n  end\n  if err == false and not _mainInited then\n    fibaro.error(__TAG,\"No main\/modules to load\")\n    return\n  end\n  local startupTime = os.clock()-t0\n  ER.utilities.printBanner(\"Rules setup time: %.3f seconds (%s rules)\",{startupTime,ER.ruleID})\n  if ER.__speedTime then ER.utilities.runTimers() end\n  \n  return ER\nend","isMain":false},{"isOpen":false,"type":"lua","name":"parser","content":"---@diagnostic disable: need-check-nil\nfibaro.__ER  = fibaro.__ER or { modules={} }\n\nfunction fibaro.__ER.modules.parser(ER)\n  \n  local fmt = string.format\n  \n  local stack,stream,errorMsg,isErrorMsg,e_error,e_pcall,errorLine,\n  marshallFrom,marshallTo,toTime,midnight,encodeFast,argsStr,eventStr,\n  PrintBuffer,sunData,LOG,LOGERR,htmlTable,evOpts,eventCustomToString =\n  table.unpack(ER.utilities.export)\n  \n  local opers0 = {\n    ['%neg']={op=false, prio=14, arity=1, trans='neg'},           -- unary minus\n    ['t\/']  ={op=true,  prio=14,  arity=1, trans='t_today'},      -- today time constant, t\/10:00\n    ['n\/']  ={op=true,  prio=14,  arity=1, trans='t_next'},       -- next today time constant, n\/10:00\n    ['+\/']  ={op=true,  prio=14,  arity=1, trans='t_plus'},       -- from today time constant, +\/10:00\n    ['$']   ={op=true,  prio=14,  arity=1, trans='gv'},           -- global variable, $var\n    ['$$']  ={op=true,  prio=14,  arity=1, trans='qv'},           -- quickApp variable, $var\n    ['$$$']  ={op=true,  prio=14,  arity=1, trans='pv'},          -- Persistent variable, $var\n    ['.']   ={op=true,  prio=12.9,arity=2, trans='aref',la=true}, -- table accessor\n    [':']   ={op=true,  prio=12.9,arity=2, trans='prop',la=true}, -- property accessor\n    ['..']  ={op=true,  prio=9,   arity=2, trans='betw'},         -- between operator, 10:00..11:00\n    ['...'] ={op=true,  prio=9,   arity=2, trans='betwo'},  \n    ['@']   ={op=true,  prio=9,   arity=1, trans='daily'},        -- day rule, @10:00\n    ['jmp'] ={op=false, prio=9,   arity=1, trans='jmp'},\n    ['::']  ={op=false, prio=9,   arity=1, trans='label'},\n    ['@@']  ={op=true,  prio=9,   arity=1, trans='interv'},       -- interval rule, @@00:05\n    ['+']   ={op=true, prio=11,   arity=2, trans='add'},\n    ['-']   ={op=true, prio=11,   arity=2, trans='sub'},\n    ['*']   ={op=true, prio=12,   arity=2, trans='mul'},\n    ['\/']   ={op=true, prio=12,   arity=2, trans='div'},\n    ['++']  ={op=true, prio=10,   arity=2, trans='conc'},         -- string concatenation\n    ['==='] ={op=true, prio=9,    arity=2, trans='match'},        -- string match\n    ['%']   ={op=true, prio=12,   arity=2, trans='mod'},          -- modulo\n    ['==']  ={op=true, prio=6,    arity=2, trans='eq'},           -- equal\n    ['<=']  ={op=true, prio=6,    arity=2, trans='lte'},\n    ['>=']  ={op=true, prio=6,    arity=2, trans='gte'},\n    ['~=']  ={op=true, prio=6,    arity=2, trans='neq'},          -- not equal\n    ['>']   ={op=true, prio=6,    arity=2, trans='gt'},\n    ['<']   ={op=true, prio=6,    arity=2, trans='lt'},\n    ['&']   ={op=true, prio=5,    arity=2, trans='f_and'},        -- logical and\n    ['|']   ={op=true, prio=4,    arity=2, trans='f_or'},         -- logical or\n    ['!']   ={op=true, prio=5.1,  arity=1, trans='f_not'},        -- logical not\n    [',']   ={op=true, prio=0.2,  arity=2, trans='elist'},        -- expression list\n    ['local']  ={op=true, prio=0.1,  arity=1, trans='f_local'},\n    ['in']  ={op=true, prio=0.1,  arity=2, trans='f_in'},\n    ['=']   ={op=true, prio=0,    arity=2, trans='assign'},       -- assignment\n    ['+=']  ={op=true, prio=0,    arity=2, trans='addto'},\n    ['-=']  ={op=true, prio=0,    arity=2, trans='subto'},\n    ['*=']  ={op=true, prio=0,    arity=2, trans='multo'},\n    [';']   ={op=true, prio=-1,   arity=2, trans='progn'},\n    [';;']  ={op=true, prio=-1.1, arity=2, trans='dprogn'},\n    ['=>']  ={op=true, prio=-10,  arity=2, trans='rule'},\n  }\n  local opers = {}\n  for k,v in pairs(opers0) do v.org = k; opers[v.trans] = v end\n  ER.opers0 = opers0\n  ER.opers = opers\n  \n  -- <EXPR> := IF <EXPR> THEN <EXPR> ELSE <EXPR> END\n  -- <EXPR> := WHILE <EXPR> DO <EXPR> END\n  -- <EXPR> := REPEAT <EXPR> DO <EXPR> END\n  -- <EXPR> := <EXPR> <OP> <EXPR>\n  -- <EXPR> := <EXPR> <OP> <EXPR>\n  -- <EXPR> := <EXPR> <OP> <EXPR>\n  \n  --\n  \n  local pExpr\n  local transform\n  local GS = 789790\n  local function gensym() GS = GS + 1; return \"GSV\"..GS end\n  local currentSource,currentRule = \"\",nil\n\n  local function DB(t) return t.d and {from=t.d.from,to=t.d.to} or {from=t.from,to=t.to} end\n  local function errorf(tk,fm,...)\n    if tk.d then tk = tk.d end\n    local err = errorMsg{type=\"Parser\",msg=fmt(fm,...):lower(),from=tk.from,to=tk.to,src=currentSource,rule=currentRule}\n    e_error(err) \n  end\n  local function assertf(tk,cond,fm,...)\n    if not cond then errorf(tk,fm,...) end\n  end\n  \n  local function prio(t) return opers[t.opval].prio end\n  local function higherPrio(op1,op2)\n    local la = opers[op1.opval].la\n    if op1.op ~= op2.op or not la then return prio(op1) > prio(op2)\n    else return prio(op1) >= prio(op2) end\n  end\n  \n  local function isConst(p)\n    return (p.type == 'num' or p.type == 'str' or p.type == 'const') and {p.value} or nil\n  end\n  ER.isParseConst = isConst\n  \n  local function pArgs(ops,st,tkns,stop)\n    local args,tkn = {},tkns.peek()\n    while tkns.peek().type ~= stop do\n      if tkns.peek().type=='eof' then errorf(tkn,'Missing %s',stop) end\n      args[#args+1] = pExpr(tkns,{['comma']=true,[stop]=true,eof=true})\n      if tkns.peek().type == 'comma' then tkns.next() end\n    end\n    tkns.next()\n    return args\n  end\n  local function pStruct(ops,st,tkns,stop)\n    local args,tkn = {},tkns.peek()\n    while tkns.peek().type ~= stop do\n      if tkns.peek().type=='eof' then errorf(tkn,'Missing %s',stop) end\n      if tkns.peek().type == 'lbra' then \n        local nt = tkns.next()\n        local k = pExpr(tkns,{['rbra']=true,eof=true})\n        if tkns.next().type~='rbra' then errorf(nt,\"Missing ']' for value key\") end\n        nt = tkns.next()\n        if nt.opval~='assign' then errorf(nt,\"Missing '=' for value key\") end\n        local v = pExpr(tkns,{['comma']=true,[stop]=true,eof=true})\n        args[#args+1] = {type='op', op='assign', args={k,v},d=DB(nt)}\n      else\n        local nt = tkns.peek()\n        local expr = pExpr(tkns,{['comma']=true,[stop]=true,eof=true})\n        if expr.op == 'assign' then\n          if nt.type ~= 'name' then errorf(nt,\"Missing name for key\") end\n          args[#args+1] = {type='op', op='keyval', args={nt.value,expr.args[2]},d=DB(nt)}\n        else\n          args[#args+1] = expr\n        end\n      end\n      if tkns.peek().type == 'comma' then tkns.next()\n      elseif tkns.peek().type ~= stop then errorf(tkn,\"Missing ',' or '%s'\",stop) end\n    end\n    tkns.next()\n    return args\n  end\n  local function apply(op,st)\n    if ER.opers[op.opval].arity == 1 then\n      local a = st.pop()\n      if a==nil then errorf(op,'Missing argument for %s',opers[op.val].org) end\n      st.push({type='op', op=op.opval, args={a},d=DB(op)})\n    else\n      local b,a = st.pop(),st.pop()\n      if a==nil then errorf(op,'Missing first argument for %s',opers[op.opval].org) end\n      if b==nil then errorf(op,'Missing second argument for %s',opers[op.opval].org) end\n      st.push({type='op', op=op.opval, abra=op.abra, args={a,b},d=DB(op)})\n    end\n  end\n  \n  local ptable = {}\n  function ptable.num(nt,ops,st,tkns,stop) st.push({type='num', value=nt.value,d=DB(nt)}) end\n  function ptable.str(nt,ops,st,tkns,stop) st.push({type='str', value=nt.value,d=DB(nt)}) end\n  function ptable.event(nt,ops,st,tkns,stop)\n    local keyvalues = {\n      type='op', op='keyval',\n      args={\n        'type',\n        {type='str', value=nt.value,d=DB(nt)},\n      },\n      d=DB(nt)\n    }\n    keyvalues = {keyvalues}\n    if tkns.peek().type == 'lcur' then\n      tkns.next()\n      local args = pStruct(ops,st,tkns,'rcur')\n      table.insert(args,1,keyvalues[1])\n      keyvalues = args\n    end\n    st.push({type='table', args=keyvalues,d=DB(nt)})\n  end\n  function ptable.lpar(nt,ops,st,tkns,stop)\n    st.push(pExpr(tkns,{['rpar']=true,eof=true}))\n    if tkns.next().type~='rpar' then errorf(nt,\"Missing ')'\") end\n  end\n  local makeForList\n  local function makeProgn(...)\n    local args = {...}\n    local t = args[#args]\n    for i=#args-1,1,-1 do\n      local e = args[i]\n      t = {type = 'op', op='progn', args={e,t}, d=DB(e)}\n    end\n    return t\n  end\n  local function filter(expr,list,nt)   -- lo cal r={}; fo r G,_ in ipairs(list) d o filter(<expr>,r) en d; r\n    local res,k = gensym(),gensym()\n    local out = {type='var', name='_', d=DB(nt)}\n    if expr.op == 'elist' then\n      out = expr.args[2]\n      expr = expr.args[1]\n    end\n    list = transform(list)\n    local liste = {type='call', name='ipairs',args={list},d=DB(nt)}\n    local r = makeProgn(\n        {type='setvar', name=res, createLocal=true, value={type='const', value={},d=DB(nt)}},\n        makeForList(k,'_',liste,{type='call', name='filter', args={expr,{type='var',name=res},out},d=DB(nt)},nt),\n        {type='var', name=res,d=DB(nt)}\n      )\n    return r\n  end\n  function ptable.lbra(nt,ops,st,tkns,stop)\n    local sub = pExpr(tkns,{['rbra']=true,eof=true})\n    if tkns.next().type~='rbra' then errorf(nt,\"Missing ']'\") end\n    if sub.op == 'f_in' then\n      st.push(filter(sub.args[1],sub.args[2],nt))\n    else\n      while not ops.isEmpty() and higherPrio(ops.peek(),{type='op', opval='aref'}) do apply(ops.pop(),st) end\n      st.push(sub)\n      ops.push({type='op', opval='aref',abra=true, d=DB(nt)})\n    end\n  end\n  function ptable.lcur(nt,ops,st,tkns,stop)\n    local args = pStruct(ops,st,tkns,'rcur')\n    st.push({type='table', args=args,d=DB(nt)})\n  end\n  \n  local constants = {['true']={true},['false']={false},['nil']={nil}}\n  function ptable.name(nt,ops,st,tkns,stop)\n    local name = nt.value\n    if constants[name] then\n      st.push({type='const', value=constants[name][1],d=DB(nt)})\n    elseif tkns.peek().type=='lpar' then\n      tkns.next()\n      local args = pArgs(ops,st,tkns,'rpar')\n      local po = ops.peek() or {}\n      if po.opval == 'prop' or po.opval == 'aref' then\n        ops.pop()\n        ops.push({type='op', opval='aref',d=DB(nt)})\n        st.push({type='var', name=name,d=DB(nt)})\n        while not ops.isEmpty() and higherPrio(ops.peek(),{type='op', opval='aref'}) do apply(ops.pop(),st) end\n        st.push({type=po.opval == 'aref' and 'callexpr' or 'callobj', expr=st.pop(), args=args,d=DB(nt)})\n        return\n      end\n      st.push({type='call', name=name, args=args,d=DB(nt)})\n    else\n      st.push({type='var', name=name,d=DB(nt)})\n    end\n  end\n  \n  function ptable.op(nt,ops,st,tkns,stop)\n    local lt = tkns.prev().type\n    if nt.opval == 'sub' and not(lt == 'name' or lt == 'num' or lt == '()' or lt == 'rpar' or lt == 'rbra') then nt.opval='neg' end\n    while not ops.isEmpty() and higherPrio(ops.peek(),nt) do apply(ops.pop(),st) end\n    ops.push(nt)\n  end\n  function ptable.t_dprogn(nt,ops,st,tkns,stop)\n    nt = {type='op', opval='dprogn'}\n    ptable.op(nt,ops,st,tkns,stop)\n  end\n  function ptable.t_if(nt,ops,st,tkns,stop)\n    local cond = pExpr(tkns,{['t_then']=true,eof=true})\n    assertf(nt,tkns.next().type== 't_then',\"missing 'THEN' for 'IF'\")\n    local th = pExpr(tkns,{['t_else']=true,['t_elseif']=true,['t_end']=true,eof=true})\n    local res = {type='f_if', cond=cond, th=th,d=DB(nt)}\n    local r = res\n    assertf(nt,tkns.peek().type~='eof',\"missing 'END' for 'IF'\")\n    while tkns.peek().type=='t_elseif' do\n      local nt2 = tkns.next()\n      local cond = pExpr(tkns,{['t_then']=true,eof=true})\n      assertf(nt2,tkns.next().type=='t_then',\"missing 'THEN' for 'ELSEIF'\")\n      local th = pExpr(tkns,{['t_else']=true,['t_elseif']=true,['t_end']=true,eof=true})\n      r.els = {type='f_if', cond=cond, th=th,d=DB(nt2)}\n      r = r.els\n      assertf(nt2,tkns.peek().type~='eof',\"missing 'END' for 'ELSEIF'\")\n    end \n    if tkns.peek().type=='t_else' then\n      local nt3 = tkns.next()\n      local f = pExpr(tkns,{['t_end']=true,eof=true})\n      assertf(nt3,tkns.peek().type=='t_end',\"missing 'END' for 'ELSE'\")\n      r.els = f\n    elseif tkns.peek().type=='t_end' then\n    else\n      errorf(nt,\"missing 'end' for 'if'\")\n    end\n    tkns.next()\n    st.push(res)\n  end\n  function ptable.t_vv(nt,ops,st,tkns,stop)\n    local cond = pExpr(tkns,{['t_gg']=true,eof=true})\n    assertf(nt,tkns.next().type== 't_gg',\"missing '>>' for '||'\")\n    local stop2 = table.copyShallow(stop)\n    stop2['t_dprogn'] = true; stop2['t_vv'] = true; stop2['eof'] = true\n    local body = pExpr(tkns,stop2)\n    local t2,res = tkns.peek()\n    if stop[t2.type] then\n      res = {type='f_if', cond=cond, th=body, d=DB(nt)}\n    elseif t2.type=='t_vv' then\n      stop = table.copyShallow(stop)\n      stop['t_dprogn'] = true\n      local els = pExpr(tkns,stop)\n      res = {type='f_if', cond=cond, th=body, els = els, d=DB(nt)}\n    else errorf(nt,\"bad ||>> expression\") end\n    st.push(res)\n  end\n  function ptable.t_while(nt,ops,st,tkns,stop)\n    local cond = pExpr(tkns,{['t_do']=true,eof=true})\n    assertf(nt,tkns.next().type=='t_do',\"missing 'DO' for 'WHILE'\")\n    local body = pExpr(tkns,{['t_end']=true,eof=true})\n    assertf(nt,tkns.next().type=='t_end',\"missing 'end' for 'WHILE'\")\n    st.push({type='f_while', cond=cond, body=body,d=DB(nt)})\n  end\n  function ptable.t_repeat(nt,ops,st,tkns,stop)\n    local body = pExpr(tkns,{['t_until']=true,eof=true})\n    assertf(nt,tkns.next().type=='t_until',\"missing 'UNTIL' for 'REPEAT'\")\n    local cond = pExpr(tkns,{progn=true,eof=true})\n    st.push({type='f_repeat', cond=cond, body=body, d=DB(nt)}) \n  end\n  \n  local function for_fun(name,const,exprs,nt)\n    return {type='forfun', name=name, const=const or {}, exprs=exprs or {}, d=DB(nt)}\n  end\n  \n  function makeForList(kvar,vvar,expr,body,nt)\n    if expr.type ~= 'call' then errorf(nt,\"Bad for loop list - expected pairs\/ipairs\") end\n    local fvar,lvar,svar = gensym(),gensym(),gensym()\n    local setup = for_fun('flsetup',{kvar,vvar,fvar,lvar,svar},{expr},nt)\n    local flinc = for_fun('flinc',{kvar,vvar,fvar,lvar},{},nt)\n    local pwhile = {\n      type = 'f_while',\n      cond = {type='var', name=kvar},\n      body = {type='op', op='progn', args={body,flinc}}\n    }\n    return {type='op', op='progn', args = {\n      setup,\n      {type='op', op='progn', args = {flinc,pwhile}, d=DB(nt)},\n      d=DB(nt)\n    }}\n  end\n  function ptable.t_for(nt,ops,st,tkns,stop)\n    local args = pExpr(tkns,{['t_do']=true,eof=true})\n    assertf(nt,tkns.next().type=='t_do',\"missing 'do' in 'for do .. end'\")\n    local body = pExpr(tkns,{t_end=true,eof=true})\n    assertf(nt,tkns.next().type=='t_end',\"missing 'end' in 'for do .. end'\")\n    if args.op == 'assign' then\n      if args.args[1].type ~= 'var' then errorf(nt,\"expected variable as index in for loop\") end\n      local idx = args.args[1].name\n      local params = transform(args.args[2])\n      if params.op ~= 'elist' then errorf(nt,\"expected start,stop in for loop\") end\n      local sav,sov,se = params.args[1],params.args[2],params.args[3] or {type='num',value=1}\n      local sgv,stopv,stepv = gensym(),gensym(),gensym()\n      local setup = for_fun('idxsetup',{idx,sgv,stopv,stepv},{sav,sov,se},nt)\n      local pwhile = {\n        type = 'f_while',\n        cond = for_fun('idxcond',{idx,sgv,stopv},nil,nt),\n        body = {type='op', op='progn', args={body,for_fun('idxinc',{idx,stepv},nil,nt)}}\n      }\n      st.push({type='op', op='progn', args = {setup,pwhile}, d=DB(nt)})\n      return\n    elseif args.op == 'f_in' then\n      local vars = args.args[1]\n      if vars.op == 'elist' then\n        for _,v in ipairs(vars.args) do\n          if v.type ~= 'var' then errorf(nt,\"Bad for loop variable\") end\n          vars[#vars+1] = v.name\n        end\n      elseif vars.type 'var' then\n        vars[1] = vars.name\n      else end\n        local expr = transform(args.args[2])\n        st.push(makeForList(vars[1],vars[2],expr,body,nt))\n    else\n      errorf(nt,\"bad 'for' expression\")\n    end\n  end\n  \n  \n  local stopReturn = {t_end=true,progn=true,eof=true}\n  function ptable.t_return(nt,ops,st,tkns,stop)\n    local t = tkns.peek()\n    if stopReturn[t.type] then\n      st.push({type='f_return',d=DB(nt)})\n    else\n      local pexpr = pExpr(tkns,stopReturn)\n      st.push({type='f_return', args=pexpr,d=DB(nt)})\n    end\n  end\n  \n  local unknownTxt = { ['rpar']=\"extra ')' at end of expression\", ['rcur']=\"extra '}' at end of expression\", ['rbra']=\"extra ']' at end of expression\"}\n  local function pExpr2(ops,st,tkns,stop)\n    while true do\n      local nt = tkns.peek()\n      if stop[nt.type] or stop[nt.opval]  then return end\n      if nt.type == 'comma' then nt.type,nt.opval='op','elist' end\n      if ptable[nt.type] then\n        tkns.next()\n        ptable[nt.type](nt,ops,st,tkns,stop)\n      else\n        if unknownTxt[nt.type] then errorf(nt,unknownTxt[nt.type])\n        else errorf(nt,\"Unknown symbol at end of expression: \"..nt.type) end\n      end\n    end\n  end\n  \n  function pExpr(tkns,stop)\n    local ops,st = stack (),stack()\n    pExpr2(ops,st,tkns,stop)\n    while not ops.isEmpty() do apply(ops.pop(),st) end\n    if st.size() > 1 then\n      errorf(st.pop(),\"Bad expression\") \n    end\n    return st.pop()\n  end\n  \n  local trans,trans_op = {},{}\n  \n  local function trans_flatten(p,typ,op)\n    local  t1 = transform(p.args[1])\n    local t2 = p.args[2]\n    if t2 == nil then return t1 end\n    local  t2 = transform(t2)\n    if t2.type == typ and t2.op==op then\n      table.insert(t2.args,1,t1)\n      return t2\n    else\n      return {type=typ, op=op, d=p.d, args={t1,t2}}\n    end\n  end\n  \n  local function assertType(t,v,msg) if not(type(v)=='table' and v.type==t) then errorf(v,msg or (\"Expected \"..t)) end end\n  function trans_op.gv(p) assertType('var',p.args[1],\"Expected name\");    return {type='gv', name=p.args[1].name} end\n  function trans_op.qv(p) assertType('var',p.args[1],\"Expected name\");    return {type='qv', name=p.args[1].name} end\n  function trans_op.pv(p) assertType('var',p.args[1],\"Expected name\");    return {type='pv', name=p.args[1].name} end\n  function trans_op.progn(p) return trans_flatten(p,'op','progn') end\n  function trans_op.dprogn(p) return trans_flatten(p,'op','progn') end\n  function trans_op.elist(p) return trans_flatten(p,'op','elist') end\n  function trans_op.f_and(p) return trans_flatten(p,'op','f_and') end\n  function trans_op.f_or(p) return trans_flatten(p,'op','f_or') end\n  function trans_op.f_local(p) p.args[1] = transform(p.args[1]) return p end\n  function trans_op.prop(p) \n    p.args[1] = transform(p.args[1])\n    if p.args[2].type~='var' then errorf(p,'Property must be a name') end\n    p.args[2] = p.args[2].name\n    return p \n  end\n  \n  -- ToDo, optimize these\n  function trans_op.addto(p) return transform({type='op', op='assign', d=p.d, args={p.args[1],{type='op', op='add', args={p.args[1],p.args[2]}}}}) end\n  function trans_op.subto(p) return transform({type='op', op='assign', d=p.d, args={p.args[1],{type='op', op='sub', args={p.args[1],p.args[2]}}}}) end\n  function trans_op.multo(p) return transform({type='op', op='assign', d=p.d, args={p.args[1],{type='op', op='mul', args={p.args[1],p.args[2]}}}}) end\n\n  local tops = {}\n  function tops.add(a,b) return a+b end\n  function tops.sub(a,b) return a-b end\n  function tops.mul(a,b) return a*b end\n  function tops.div(a,b) return a\/b end\n  function tops.mod(a,b) return a%b end\n  \n  local arithSingle = {add='addto',mul='multo',sub='subto',div='divto',mod='modto'}\n  local function trans_op_calc(p)\n    local  t1 = transform(p.args[1])\n    local  t2 = transform(p.args[2])\n    if t1.type == 'num' and t2.type=='num' and tops[p.op] then\n      return {type='num', value=tops[p.op](t1.value,t2.value) ,d=p.d}\n    elseif not arithSingle[p.op] then\n      return {type='op', op=p.op, args={t1,t2}, d=p.d}\n    elseif t1.type == 'num' then\n      return {type=arithSingle[p.op], const=t1.value, arg=t2, rev=false, d=p.d}\n    elseif t2.type == 'num' then\n      return {type=arithSingle[p.op], const=t2.value, arg=t1, rev=true, d=p.d}\n    end\n    return {type='op', op=p.op, args={t1,t2}, d=p.d}\n  end\n  \n  trans_op.add = trans_op_calc\n  trans_op.sub = trans_op_calc\n  trans_op.mul = trans_op_calc\n  trans_op.div = trans_op_calc\n  trans_op.mod = trans_op_calc\n  function trans_op.neg(p)\n    local t1 = transform(p.args[1])\n    if t1.type == 'num' then return {type='num', value=-t1.value, d=p.d}\n    else return {type='op', op='neg', args={t1}, d=p.d} end\n  end\n  \n  local _rvalues = {var='var',aref='aref',prop='prop',gv='gv',qv='qv',pv='pv'}\n  local function isRvalue(p) return _rvalues[p.type] or _rvalues[p.op] end\n  local _l2rvalue = {\n    var = function(p,value) return {type='setvar', name=p.name, value=value, d=DB(p)} end,\n    gv = function(p,value) return {type='setgv', name=p.name, value=value, d=DB(p)} end,\n    qv = function(p,value) return {type='setqv', name=p.name, value=value, d=DB(p)} end,\n    pv = function(p,value) return {type='setpv', name=p.name, value=value, d=DB(p)} end,\n    aref = function(p,value) return {type='aset', tab=p.tab, key=p.key, value=value,d=DB(p)} end,\n    prop = function(p,value) return {type='putprop', device=p.args[1], prop=p.args[2], value=value, d=DB(p)} end,\n  }\n  local function LtoRvalue(p,value) local l=isRvalue(p) return l and _l2rvalue[l](p,value) end\n\n  local cID = 1\n  function trans_op.assign(p)\n    local  t1 = transform(p.args[1])\n    local  t2 = transform(p.args[2])\n    local lv = LtoRvalue(t1,t2)\n    if lv then return lv\n    elseif t1.type == 'op' then\n      local createLocal\n      if t1.op=='prop' then return LtoRvalue(t1,t2) end\n      if t1.op=='f_local' then\n        if t1.args[1].type=='var' then \n          return {type='setvar', name=t1.args[1].name, value=t2, createLocal=true, d=DB(p)}\n        elseif t1.args[1].op == 'elist' then\n          t1.op = 'elist' -- treat it as an elist\n          t1.args = t1.args[1].args\n          createLocal = true\n        end\n      end\n      if t1.op=='elist' then -- multiple value, make right hand a collect statement\n        local tag = \"c\"..cID; cID = cID +1\n        if t2.op=='elist' then\n          t2 = {type='collect', args=t2.args, tag=tag}\n        else\n          t2 = {type='collect', args={t2}, tag=tag}\n        end\n        local dest,n = {},#t1.args\n        for i,d in ipairs(t1.args) do\n          if not isRvalue(d) then errorf(p,'Left hand side of multiple assignment must be a variable or table accessor') end\n          local lv = LtoRvalue(d,{type='mv', id=i, tag=tag, size=n, free=i==n})\n          lv.createLocal = createLocal\n          dest[#dest+1] = lv\n        end\n        return {type='massign', dest=dest, arg=t2}\n      end\n    end\n    errorf(p,'Left hand side of assignment unsupported')\n  end\n  \n  function trans_op.rule(p) \n    local cond = transform(p.args[1])\n    local action = transform(p.args[2])\n    return {type='rule', cond=cond, action = action} \n  end\n  \n  function trans_op.daily(p)\n    p.args[1] = transform(p.args[1])\n    local arg = p.args[1]\n    if arg.type ~= 'table' and not (arg.type=='const' and type(arg.value)=='table') then\n      local narg = transform({type='table', args={arg}, d=arg.d})\n      p.args[1] = narg\n    end\n    return p\n  end\n\n  function trans_op.aref(p)\n    local key = transform(p.args[2])\n    if not p.abra then\n      local k = isConst(key)\n      if (not k) and key.type == 'var' then k = {key.name} end\n      if k then \n        key = {type='const', value=k[1], d=DB(p)}\n        local tab = transform(p.args[1])\n        return {type='aref', tab=tab, key=key, d=DB(p)}\n      end\n      --errorf(key,\"Table .key must be a name\")\n    end\n    local tab = transform(p.args[1])\n    return {type='aref', tab=tab, key=key, d=DB(p)}\n  end\n  \n  function trans.putprop(p)\n    p.device = transform(p.device)\n    p.prop = transform(p.prop)\n    p.value = transform(p.value)\n    return p\n  end\n  \n  local function transformList(l) for i,v in pairs(l) do l[i] = transform(v) end end\n  \n  function trans.call(p) transformList(p.args); return p end\n  function trans.callexpr(p) transformList(p.args); p.expr = transform(p.expr); return p end\n  function trans.callobj(p) transformList(p.args); p.expr = transform(p.expr); return p end\n  \n  -- function trans.filter(p)\n  --   p.expr = transform(p.expr)\n  --   p.list = transform(p.list)\n  --   return p\n  -- end\n  function trans.f_while(p) \n    p.cond = transform(p.cond)\n    p.body = transform(p.body)\n    return p\n  end\n  function trans.f_repeat(p)\n    p.cond = transform(p.cond)\n    p.body = transform(p.body)\n    return p\n  end\n  function trans.f_if(p)\n    p.cond = transform(p.cond)\n    p.th = transform(p.th)\n    if p.els then p.els = transform(p.els) end\n    return p\n  end\n  function trans.f_return(p) p.args = transform(p.args) return p end\n  function trans.op(p)\n    if trans_op[p.op] then return trans_op[p.op](p) \n    else\n      for i=1,#p.args do p.args[i] = transform(p.args[i]) end\n      return p\n    end\n  end\n  \n  function trans.table(p) -- split up assignments and check if constant table\n    local args,nargs,ct,index = p.args,{},{},0\n    local const = true\n    if #args == 0 then return {type='const', value={}, d=p.d} end\n    for _,v in ipairs(args) do\n      if v.op == 'assign' then\n        local v1 = transform(v.args[1])\n        local v2 = transform(v.args[2])\n        local c1 = isConst(v1)\n        const = const and c1~=nil and isConst(v2)~=nil\n        if c1 and c1[1]~=nil then nargs[#nargs+1]={'const',c1[1],v2}\n        else nargs[#nargs+1]={'comp',v1,v2} end\n      elseif v.op == 'keyval' then\n        local key = v.args[1]\n        local v2 = transform(v.args[2])\n        const = const and isConst(v2)~=nil\n        nargs[#nargs+1]={'const',key,v2}\n      else\n        index = index+1\n        v = transform(v)\n        const = const and isConst(v)~=nil\n        nargs[#nargs+1]={'const',index,v}\n      end\n    end\n    if const then \n      for _,v in ipairs(nargs) do\n        ct[v[2]] = isConst(v[3])[1]\n      end\n      return {type='const', value=ct, d=p.d}\n    end\n    return {type='table', value=nargs, d=p.d}\n  end\n  \n  function trans.num(p) return p end\n  function trans.str(p) return p end\n  function trans.var(p) return p end\n  function trans.const(p) return p end\n  function trans.forfun(p) return p end\n  \n  function transform(p)\n    if trans[p.type] then return trans[p.type](p) else \n      return p \n    end\n  end\n  \n  local simpTab,simp,simpList = {},nil,nil\n  function simpTab.num(v) return v.value end\n  function simpTab.str(v) return v.value end\n  function simpTab.name(v) return v.value end\n  function simpTab.const(v) return tostring(v.value) end\n  function simpTab.event(v) return {'ev',v.value} end\n  function simpTab.setvar(v) return {'setvar',v.name,simp(v.value)} end\n  function simpTab.f_if(v) return {'if',simp(v.cond),simp(v.th),v.els and simp(v.els) or nil} end\n  function simpTab.f_while(v) return {'while',simp(v.cond),simp(v.body)} end\n  function simpTab.f_repeat(v) return {'repeat',simp(v.cond),simp(v.body)} end\n  function simpTab.call(v) return {'call',v.name,simpList(v.args)} end\n  function simpTab.callexpr(v) return {'call',simp(v.expr),simpList(v.args)} end\n  function simpTab.callobj(v) return {'callobj',simp(v.expr),simpList(v.args)} end\n  function simpTab.assign(v) return {'set',simp(v.dest),simp(v.arg)} end\n  function simpTab.massign(v) return {'mset',simpList(v.dest),simp(v.arg)} end\n  function simpTab.aset(v) return {'aset',simp(v.tab),simp(v.key),simp(v.value)} end\n  function simpTab.putprop(v) return {'puprop',simp(v.device),simp(v.key),simp(v.value)} end\n  function simpTab.collect(v) return {'collect',simpList(v.args)} end\n  function simpTab.aref(v) return {'aref',simp(v.tab),simp(v.key)} end\n  function simpTab.op(v)\n    local p = simpList(v.args)\n    table.insert(p,1,v.op)\n    return p\n  end\n  \n  function simp(v) v.d=nil return simpTab[v.type] and simpTab[v.type](v) or v[1] and simpList(v) or v end\n  function simpList(l) local r = {}; for _,v in ipairs(l) do r[#r+1]=simp(v) end; return r end\n  ER.simplifyParseTree = function (p) return simp(p) end\n\n  function ER:parse(input,options) -- codeStr\/tokens -> parseTree\n    local tkns,pexpr,sf \n    local source = \"\"\n    currentRule = options.rule\n    local stat,res = e_pcall(function() \n      if type(input) == 'string' then\n        currentSource = input\n        tkns = ER:tokenize(input)\n        source = input\n      elseif type(input) == 'table' then\n        if options.src then source = options.src end\n        tkns = input\n      else\n        error(\"Parser expected string or token stream\")\n      end\n      currentSource = source\n\n      pexpr = pExpr(tkns,{eof=true})\n      pexpr = transform(pexpr)\n      if options.simplifyParseTree then pexpr = simp(pexpr) sf=true end\n      return pexpr\n    end)\n\n    if stat then -- Valid result, return printable table (i.g. parse tree)\n      return type(res)=='table' and setmetatable(res,{__tostring=function (t) return encodeFast(t) end}) or res\n    else\n      local err = res   -- error, return informative error msg\n      if not sf and pexpr then -- try to simplify parse tree\n        local stat,nexpr = pcall(simp,pexpr) -- but it could crash...\n        pexpr = stat and nexpr or pexpr\n      end\n      if not isErrorMsg(err) then\n        local last = tkns.last()\n        err = errorMsg{type=\"Parser\",msg=err,from=last.from,to=last.to,src=source,rule=options.rule}\n      end\n      e_error(err)\n    end\n  end\n  \nend","isMain":false},{"isOpen":false,"type":"lua","name":"tokenizer","content":"fibaro.__ER  = fibaro.__ER or { modules={} }\n\nfunction fibaro.__ER.modules.tokenizer(ER)\n  local toTime = fibaro.toTime\n  \n  \n  local fmt = string.format\n  local patterns = {}\n  \n  local function toTimeDate(str)\n    local y,m,d,h,min,s=str:match(\"(%d?%d?%d?%d?)\/?(%d+)\/(%d+)\/(%d%d):(%d%d):?(%d?%d?)\")\n    local t = os.date(\"*t\")\n    return os.time{year=y~=\"\" and y or t.year,month=m,day=d,hour=h,min=min,sec=s~=\"\" and s or 0}\n  end\n  \n  local tokenMetatable = {\n    __tostring = function (t) return fmt(\"%s:%s\/%s\/%s\",t.type,t.value or t.opval,t.from,t.to) end\n  }\n  \n  local function token(prefix, pattern, createFn)\n    pattern = \"^(\" .. pattern .. \")\"\n    local function fn(ctx)\n      local _, len, res, group = string.find(ctx.source, pattern)\n      if len then\n        if createFn then\n          local tokenv,t2,len2 = createFn(group or res, ctx.source)\n          if tokenv == '%extend%' then\n            tokenv = t2\n            len = len2\n          end\n          tokenv.from, tokenv.to = ctx.cursor+1, ctx.cursor+len\n          table.insert(ctx.tokens, tokenv)\n          setmetatable(tokenv, tokenMetatable)\n          --print(tokenv)\n        end\n        ctx.source = string.sub(ctx.source, len+1)\n        ctx.cursor = ctx.cursor + len\n        return true\n      end\n    end\n    for c in prefix:gmatch\".\" do\n      patterns[c] = patterns[c] or {}\n      table.insert(patterns[c], fn)\n    end\n  end\n  \n  local nopers = {['jmp']=true,}--['return']=true}\n  local SW={['(']='lpar',[')']='rpar',['{']='lcur',['}']='rcur',['[']='lbra',[']']='rbra',['||']='lor',[',']='comma'}\n  local function checkOp(op) return ER.opers0[op] and ER.opers0[op].op and \"op\" or \"badop\" end\n  local function keywordOp(op) return ER.opers0[op] and ER.opers0[op].op end\n  local function trans(op) return ER.opers0[op] and ER.opers0[op].trans or op end\n  local keyword={\n    ['if']='t_if',['then']='t_then',['else']='t_else',['elseif']='t_elseif',['end']='t_end',['while']='t_while',\n    ['repeat']='t_repeat',['do']='t_do',['until']='t_until',['return']='t_return',['for']='t_for',\n  }\n  \n  token(\" \\t\\n\\r\",\"[%s%c]+\")\n  --2019\/3\/30\/20:30\n  token(\"\/0123456789\",\"%d?%d?%d?%d?\/?%d+\/%d+\/%d%d:%d%d:?%d?%d?\",function (t) return {type=\"num\", value=toTimeDate(t)} end)\n  token(\"0123456789\",\"%d%d:%d%d:?%d?%d?\",function (t) return {type='num', value=toTime(t)} end)\n  token(\"0123456789\",\"%d+:%d+\",function (_) error('Bad time constant') end)\n  token(\"t+n\",\"[t+n][\/]\", function (op) return {type=\"op\", opval=trans(op)} end)\n  token(\"#\",\"#[A-Za-z_][%w_%-]*\",function (w) return {type=\"event\", value=w:sub(2)} end)\n  --token(\"[A-Za-z_][%w_]*\", function (w) return {type=nopers[w] and 'operator' or \"name\", sw=nopers[w] and 'op' or 'nam', value=w} end)\n  token(\"_abcdefghijklmnopqrstuvwxyzåäöABCDEFGHIJKLMNOPQRSTUVWXYZÅÄÖ\\xC3\\xA5\\xA4\\xB6\\x85\\x84\\x96\",\"[_a-zA-Z\\xC3\\xA5\\xA4\\xB6\\x85\\x84\\x96][_0-9a-zA-Z\\xC3\\xA5\\xA4\\xB6\\x85\\x84\\x96]*\", \n  function (w) return keywordOp(w) and {type='op',opval=trans(w)} or {type=keyword[w] or \"name\", value=w} end)\n  token(\"0123456789\",\"%d+%.%d+\", function (d) return {type=\"num\", value=tonumber(d)} end)\n  token(\"0123456789\",\"%d+\", function (d) return {type=\"num\", value=tonumber(d)} end)\n  local csubs = {['\\\\n']='\\n',['\\\\r']='\\r',['\\\\t']='\\t'}\n  local cmap = {['n']='\\n',['r']='\\r',['t']='\\t'}\n  local function getString(s,e)\n    local i,n = 2,s:len()\n    local r = {}\n    while i <= n do\n      local c = s:sub(i,i)\n      if c == '\\\\' then\n        i = i + 1\n        c = s:sub(i,i)\n        r[#r+1]=cmap[c] or c\n      elseif c == e then\n        return table.concat(r),i\n      else r[#r+1]=c end\n      i=i+1\n    end\n  end\n  token('\"','\"', function (s,src)\n    local str,i = getString(src,'\"')\n    if not str then error('unfinished string starting with \"...') end\n    return '%extend%', {type=\"str\", value=str}, i\n  end)\n  token(\"'\",\"'\", function (s,src)\n    local str,i = getString(src,\"'\")\n    if not str then error(\"unfinished string starting with '...\") end\n    return '%extend%', {type=\"str\", value=str}, i\n  end)\n  token(\"-\",\"%-%-.-\\n\")\n  token(\"-\",\"%-%-.*\")\n  token(\">\",\">>\",function() return {type=\"t_gg\", value=\">>\"} end)\n  token(\"|\",\"||\",function() return {type=\"t_vv\", value=\">>\"} end)\n  token(\";\",\";;\",function() return {type=\"t_dprogn\", value=\";;\"} end)\n  token(\"=\",\"===\",function (op) return {type=\"op\", opval=trans(op)} end)    \n  token(\".\",\"%.%.%.\",function (op) return {type=\"op\", opval=trans(op)} end)\n  token(\"$\",\"%$%$%$?\", function (op) return {type=\"op\", opval=trans(op)} end)\n  token(\"@$=<>!+.-*&|\/^~;:\",\"[@%$=<>!+%.%-*&|\/%^~;:][%+@=<>&|;:%.]?\", function (op) return {type=checkOp(op), opval=trans(op)} end)\n  token(\"{}(),[]#%\",\"[{}%(%),%[%]#%%]\", function (op) return {type=SW[op] or checkOp(op), opval=trans(op)} end)\n  \n  local function dispatch(c,ctx) \n    for _,m in ipairs(patterns[c] or {}) do\n      if m(ctx) then return true end\n    end\n  end\n  \n  local function tokenize(src)\n    local ctx = { source = src, tokens = {}, cursor = 0 }\n    while #ctx.source>0 and dispatch(ctx.source:sub(1,1),ctx) do end\n    if #ctx.source > 0 then \n      error(fmt(\"tokenizer failed at %s in %s\",ctx.source,src))\n    end\n    return ctx.tokens\n  end\n  \n  function ER:tokenize(str)\n    return ER.utilities.stream(tokenize(str))\n  end\n  \nend","isMain":false},{"isOpen":false,"type":"lua","name":"compiler","content":"fibaro.__ER  = fibaro.__ER or { modules={} }\n\nfunction fibaro.__ER.modules.compiler(ER)\n  \n  local stack,stream,errorMsg,isErrorMsg,e_error,e_pcall,errorLine,\n  marshallFrom,marshallTo,toTime,midnight,encodeFast,argsStr,eventStr,\n  PrintBuffer,sunData,LOG,LOGERR,htmlTable,evOpts =\n  table.unpack(ER.utilities.export)\n\n  local isParseConst = ER.isParseConst\n  local errorMsg = ER.utilities.errorMsg\n  local e_error = ER.utilities.xerror\n  \n  local compile\n  local function makeOut()\n    local self,code,dbg = {},{},{}\n    self.code,self.dbg = code,dbg\n    function self.instr(p,...) \n      local i = {...}\n      table.insert(i,2,#i-1) code[#code+1]=i \n      dbg[i] = p\n      return i\n    end\n    return self\n  end\n  \n  local currentSource = \"\"\n  local function errorf(p,fm,...)\n    if p.d then p = p.d end\n    local err = errorMsg{type=\"Compiler\",msg=string.format(fm,...),from=p.from,to=p.to,src=currentSource}\n    e_error(err) \n  end\n  \n  local comp,comp_op = {},{}\n  \n  function comp.num(p,out) out.instr(p,'push',p.value) end\n  function comp.str(p,out) out.instr(p,'push',p.value) end\n  function comp.var(p,out)\n    if ER.constants[p.name] then\n      out.instr(p,p.name)\n    else\n      out.instr(p,'var',p.name)\n    end\n  end\n  function comp.const(p,out) \n    if type(p.value) == 'table' then \n      out.instr(p,'pushc',p.value) \n    else\n      out.instr(p,'push',p.value) \n    end\n  end\n  function comp.gv(p,out) out.instr(p,'gv',p.name) end\n  function comp.qv(p,out) out.instr(p,'qv',p.name) end\n  function comp.pv(p,out) out.instr(p,'pv',p.name) end\n  function comp.addto(p,out) compile(p.arg,out); out.instr(p,p.type,p.const,p.rev) end\n  function comp.multo(p,out) compile(p.arg,out); out.instr(p,p.type,p.const,p.rev) end\n  function comp.subto(p,out) compile(p.arg,out); out.instr(p,p.type,p.const,p.rev) end\n  function comp.divto(p,out) compile(p.arg,out); out.instr(p,p.type,p.const,p.rev) end\n  function comp.modto(p,out) compile(p.arg,out); out.instr(p,p.type,p.const,p.rev) end\n  function comp.op(p,out)\n    if comp_op[p.op] then\n      comp_op[p.op](p,out)\n    else\n      for _,a in ipairs(p.args) do compile(a,out) end\n      out.instr(p,p.op)\n    end\n  end\n  function comp.f_not(p,out)\n    compile(p.args[1],out)\n    out.instr(p,'f_not')\n  end\n  function comp.f_if(p,out)\n    compile(p.cond,out)\n    if p.els==nil then\n      local i,pc = out.instr(p,'jmpf',0),#out.code\n      compile(p.th,out)\n      i[3] = #out.code-pc+1\n    else\n      local i,pc = out.instr(p,'jmpfp',0),#out.code\n      compile(p.th,out)\n      local e,pc2= out.instr(p,'jmp',0),#out.code\n      i[3] = #out.code-pc+1\n      compile(p.els,out)\n      e[3] = #out.code-pc2+1\n    end\n  end\n  \n  function comp.rule_action(p,out)\n    compile(p.cond,out)\n    out.instr(p,'rule_action')\n    compile(p.action,out)\n  end\n  \n  function comp_op.f_and(p,out)\n    local jmps = {}\n    for i=1,#p.args-1 do \n      compile(p.args[i],out)\n      jmps[#jmps+1] = {out.instr(p,'jmpf',0),#out.code}\n    end\n    compile(p.args[#p.args],out)\n    for _,j in ipairs(jmps) do j[1][3] = #out.code-j[2]+1 end\n  end\n  \n  function comp_op.f_or(p,out)\n    local jmps = {}\n    for i=1,#p.args-1 do \n      compile(p.args[i],out)\n      jmps[#jmps+1] = {out.instr(p,'jmpt',0),#out.code}\n    end\n    compile(p.args[#p.args],out)\n    for _,j in ipairs(jmps) do j[1][3] = #out.code-j[2]+1 end\n  end\n  \n  function comp_op.prop(p,out)\n    local val = p.args[1]\n    local prop = p.args[2]\n    compile(val,out)\n    out.instr(p,'prop',prop) \n  end\n  \n  function comp_op.elist(p,out) comp_op.progn({type='op',args=p.args},out) end\n\n  function comp.aref(p,out)\n    local k = isParseConst(p.key)\n    if k then\n      compile(p.tab,out)\n      out.instr(p.tab,'aref',false,k)\n    else\n      compile(p.tab,out)\n      compile(p.key,out)\n      out.instr(p,'aref',false,false) -- variable,constant key\n    end\n  end\n  \n  function comp.aset(p,out)\n    compile(p.tab,out)\n    local k = isParseConst(p.key)\n    if not k then compile(p.key,out) end\n    local v = isParseConst(p.value)\n    if not v then compile(p.value,out) end\n    out.instr(p,'aset',k and k[1] or nil,v,false) -- variable,constant key,constant value,pop value\n  end\n  \n  function comp.putprop(p,out)\n    -- {type='putprop', device=p.args[1], prop=p.args[2], value=value}\n    compile(p.device,out)\n    compile(p.value,out)\n    out.instr(p,'putprop',p.prop)\n  end\n  function comp.call(p,out)\n    for _,arg in ipairs(p.args) do compile(arg,out) end\n    local n = table.maxn(p.args)\n    if ER.builtins[p.name] then\n      local d = ER.builtinArgs[p.name]\n      if d then if n < d[1] or n > d[2] then errorf(p,\"Wrong number of arguments for builtin '%s' (%s,%s)\",p.name,d[1],d[2]) end end\n      out.instr(p,p.name,n)\n    else\n      out.instr(p,'call',p.name,n)\n    end\n  end\n  function comp.callexpr(p,out)\n    compile(p.expr,out)\n    for _,arg in ipairs(p.args) do compile(arg,out) end\n    out.instr(p,'call',false,#p.args)\n  end\n  function comp.callobj(p,out)\n    local tab = p.expr\n    local k = isParseConst(tab.key)\n    compile(tab.tab,out)              \n    out.instr(p,'aref',false,k,true) -- aref that pushes tab on the stack and becomes first arg to call\n    for _,arg in ipairs(p.args) do compile(arg,out) end\n    out.instr(p,'call',false,#p.args+1)\n  end\n\n  local popInstr = { setvar = true, aset=true, push=false }\n  function comp_op.progn(p,out)\n    if #p.args == 0 then return end\n    for i=1,#p.args-1 do \n      compile(p.args[i],out)\n      local ins = out.code[#out.code]\n      local dopop = popInstr[ins[1]]\n      if dopop~=nil then \n        if dopop then ins[5] = true\n        else table.remove(out.code,#out.code) end\n      else\n        --print(\"POP after\",ins[1])\n        out.instr(p,'pop') \n      end\n    end\n    compile(p.args[#p.args],out)\n  end\n  function comp.f_while(p,out)   -- A <cond> jmpf B <body> jmpp A, B\n    local start = #out.code+1\n    compile(p.cond,out)\n    local acond = #out.code\n    local e = out.instr(p,'jmpf',0)\n    compile(p.body,out)\n    out.instr(p,'jmpp',start-#out.code-1)\n    e[3] = #out.code-acond\n  end\n  function comp.f_repeat(p,out) -- A <progn> jmpfp A\n    local start,body = #out.code+1,p.body\n    if p.body.op=='progn' then\n      table.insert(body.args,p.cond)\n    else\n      body = {type='op',op='progn',args={p.body,p.cond}}\n    end\n    compile(body,out)\n    out.instr(p,'jmpfip',start-#out.code-1)\n  end\n  \n  function comp.forfun(p,out)\n    local name,const,exprs = p.name,p.const,p.exprs\n    local n = table.maxn(exprs)\n    for i=1,n  do compile(exprs[i],out) end\n    out.instr(p,p.name,n,table.unpack(p.const))\n  end\n  \n  function comp.f_return(p,out)\n    local args = p.args\n    if args == nil then out.instr(p,'return0')\n    elseif args.op == 'elist' then\n      for _,arg in ipairs(args.args) do compile(arg,out) end\n      out.instr(p,'returnm',#args.args)\n    else\n      compile(args,out)\n      out.instr(p,'return1')\n    end \n  end\n  \n  -- x,y = 3,4\n  -- collect(tag,3,4)\n  -- x = mv(tag,1); y = mv(tag,2,delete)\n  \n  -- x,y = foo()\n  -- local t1,t2 = foo()\n  -- x = t1; y = t2\n  \n  function comp.setvar(p,out)\n    if p.createLocal then out.instr(p,'local',p.name) end\n    local c = isParseConst(p.value)\n    if c then \n      out.instr(p,'setvar',p.name,c,false)\n    else\n      compile(p.value,out)\n      out.instr(p,'setvar',p.name,false,false)\n    end\n  end\n  function comp.setgv(p,out)\n    local c = isParseConst(p.value)\n    if c then \n      out.instr(p,'setgv',p.name,c,false)\n    else\n      compile(p.value,out)\n      out.instr(p,'setgv',p.name,false,false)\n    end\n  end\n  function comp.setqv(p,out)\n    local c = isParseConst(p.value)\n    if c then \n      out.instr(p,'setqv',p.name,c,false)\n    else\n      compile(p.value,out)\n      out.instr(p,'setqv',p.name,false,false)\n    end\n  end\n  function comp.setpv(p,out)\n    local c = isParseConst(p.value)\n    if c then \n      out.instr(p,'setpv',p.name,c,false)\n    else\n      compile(p.value,out)\n      out.instr(p,'setpv',p.name,false,false)\n    end\n  end\n  function comp_op.f_local(p,out)   -- like massign but assignments creates locals\n    compile(p.arg,out)\n    for i,v in ipairs(p.dest) do compile(v,out) end\n  end\n  function comp.massign(p,out)\n    compile(p.arg,out)\n    for i,v in ipairs(p.dest) do compile(v,out) end\n  end\n  function comp.mv(p,out) out.instr(p,'mv',p.tag,p.id,p.size,p.free) end\n  function comp.collect(p,out)\n    out.instr(p,'mvstart',p.tag)\n    local args = p.args\n    for _,arg in ipairs(args) do compile(arg,out) end\n    out.instr(p,'mvend',p.tag)\n  end\n\n  function comp.table(p,out)\n    local args,keys = p.value,{}\n    for i,v in pairs(args) do\n      if v[1]=='const' then\n        keys[#keys+1]=v[2]\n        compile(v[3],out)\n      else\n        compile(v[2],out)\n        compile(v[3],out)\n        keys[#keys+1] = '%comp%'\n        keys[#keys+1] = '%value%'\n      end\n    end\n    out.instr(p,'table',keys)\n  end\n  function comp.eventm(p,out) out.instr(p,'eventm',p.evid,p.event) end\n  \n  function comp.rule(p,out) out.instr(p,'rule',p.cond,p.action) end\n  \n  function compile(p,out)\n    if p == nil then\n      error(\"compile: nil parse node\")\n    end\n    --print(json.encode(p))\n    if comp[p.type] then\n      comp[p.type](p,out)\n    else\n      error(\"Unknown parse node type: \"..json.encode(p.type))\n    end\n  end\n  \n  local fID = 0\n  function ER:compile(input,options) --> codeString\/ParseTree -> Function\n    currentSource = options.src\n    local parseTree\n    if type(input) == 'string' then -- assume we got a code, parse to parseTree\n      local token = ER:tokenize(input)\n      parseTree = ER:parse(token)\n    elseif type(input) == 'table' then -- we got a parseTree\n      parseTree = input\n    else \n      error(\"compile: bad input type to compile: \"..type(input)) \n    end\n    local out = makeOut()\n    compile(parseTree,out)\n    fID = fID+1\n    local codestr = {name = options.name or fID, src = options.src, code = out.code, dbg = out.dbg, timestamp =os.time()}\n    return ER:createFun(codestr,options)\n  end\n  \nend","isMain":false},{"isOpen":false,"type":"lua","name":"vm","content":"fibaro.__ER  = fibaro.__ER or { modules={} }\n\nfunction fibaro.__ER.modules.vm(ER)\n  \n  local stack,stream,errorMsg,isErrorMsg,e_error,e_pcall,errorLine,\n  marshallFrom,marshallTo,toTime,midnight,encodeFast,argsStr,eventStr,\n  PrintBuffer,sunData,LOG,LOGERR,htmlTable,evOpts,eventCustomToString =\n  table.unpack(ER.utilities.export)\n  \n---@diagnostic disable-next-line: deprecated\n  local maxn = table.maxn\n  local function coerce(x,y) local x1 = tonumber(x) if x1 then return x1,tonumber(y) else return x,y end end\n  local vars,triggerVars = ER._vars,ER._triggerVars\n  local fmt = string.format\n  local settings = ER.settings\n\n  local function errorf(p,fm,...)\n    local fun = p.fun or p.co.fun\n    local dbg = fun.dbg[fun.code[p.pc]]\n    dbg = dbg and dbg.d or {}\n    local err = errorMsg{type=\"Runtime\",msg=fmt(fm,...),from=dbg.from,to=dbg.to,src=fun.src,rule=p.rule}\n    e_error(err) \n  end\n  \n  local function Environment()\n    local self = { }\n    local vars = {}\n    function self.popframe() vars = vars.__next or {} end              -- pop frame\n    function self.pushframe() vars.__next = {} vars = vars.__next end  -- add frame\n    function self.get(v)  -- lookup var in nested environments\n      local vf = vars \n      while vf.__next do if vf[v] then return vf[v] end vf = vf.__next end\n      return vf[v] \n    end\n    function self.push(v,val) vars[v] = {val} end                      -- push var in current environment\n    function self.set(v,val) -- set var in nested environments\n      local vf = vars \n      while vf.__next do if vf[v] then vf[v][1]=val; return true end vf = vf.__next end\n      if vf[v] then vf[v][1]=val; return true else return false end\n    end \n    return self\n  end\n  \n  local Script = {}\n  local _DflSc = {  -- Default Script context\n    _post = function(ev,t,dscr,p) return fibaro.post(ev,t) end, \n    _cancelPost = function(ref) return fibaro.cancel(ref) end, \n    _setTimeout = function(fun,delay,descr) return setTimeout(fun,delay) end,\n    _clearTimeout = function(ref) return clearTimeout(ref) end,\n  } -- default script context, deals with variables timers etc for rules, coroutines, and plain functions\n  function Script.get(name) return vars[name] or {_G[name]} end\n  function Script.set(name,value) \n    local v,old = vars[name],nil\n    if v then old=v[1] v[1]=value else vars[name]={value} end\n    return true,old\n  end\n  function Script.post(p,event,time,descr) return (p.rule or p.co or _DflSc)._post(event,time,descr,p) end\n  function Script.cancel(p,event,time,descr) return (p.rule or p.co or _DflSc)._cancelPost(event) end\n  function Script.setTimeout(p,fun,time,descr) return (p.rule or p.co or _DflSc)._setTimeout(fun,time,descr) end\n  function Script.clearTimeout(p,ref) return (p.rule or p.co or _DflSc)._clearTimeout(ref) end\n  function Script.print(...) print(...) end\n  ER.Script = Script\n\n  local copy = table.copy\n\n  local instr,ilog,errh = {},{},{}\n  local PA = {}\n  local function cmpVal(x) local m = getmetatable(x) return m and m.__cmpVal and m.__cmpVal(x) or x end\n  function instr.push(i,st)     st.push(i[3]) end\n  function instr.pushc(i,st)    st.push(copy(i[3])) end\n  function instr.pop(i,st)      st.pop() end\n  function instr.dup(i,st)      st.push(st.peek()) end\n  function instr.swap(i,st)     local b,a = st.pop(),st.pop(); st.push(b); st.push(a) end\n  function instr.jmp(i,st,p)    p.pc = p.pc + i[3]-1 end\n  function instr.jmpp(i,st,p)   st.pop(); p.pc = p.pc + i[3]-1 end\n  function instr.jmpf(i,st,p)  local v = st.peek() if not v then p.pc = p.pc + i[3]-1 else st.pop() end end\n  function instr.jmpfip(i,st,p)local v = st.peek() if not v then p.pc = p.pc + i[3]-1 st.pop() end end\n  function instr.jmpfp(i,st,p) local v = st.pop() if not v then p.pc = p.pc + i[3]-1 end end\n  function instr.jmpt(i,st,p)  local v = st.peek() if v then p.pc = p.pc + i[3]-1 else st.pop() end end\n  function instr.add(i,st)     local b,a = st.pop(),st.pop() PA={a,b} st.push(a+b) end \n  function instr.sub(i,st)     local b,a = st.pop(),st.pop() PA={a,b} st.push(a-b) end \n  function instr.mul(i,st)     local b,a = st.pop(),st.pop() PA={a,b} st.push(a*b) end\n  function instr.div(i,st)     local b,a = st.pop(),st.pop() PA={a,b} st.push(a\/b) end \n  function instr.mod(i,st)     local b,a = st.pop(),st.pop() PA={a,b} st.push(a%b) end \n  function instr.eq(i,st)      local b,a = st.pop(),st.pop() PA={a,b} st.push(cmpVal(a)==cmpVal(b)) end \n  function instr.neq(i,st)     local b,a = st.pop(),st.pop() PA={a,b} st.push(cmpVal(a)~=cmpVal(b)) end \n  function instr.lt(i,st)      local b,a = coerce(st.pop(),st.pop()) PA={a,b} st.push(a<b) end \n  function instr.lte(i,st)     local b,a = coerce(st.pop(),st.pop()) PA={a,b} st.push(a<=b) end \n  function instr.gt(i,st)      local b,a = coerce(st.pop(),st.pop()) PA={a,b} st.push(a>b) end \n  function instr.gte(i,st)     local b,a = coerce(st.pop(),st.pop()) PA={a,b} st.push(a>=b) end\n  function instr.match(i,st)   local b,a = tostring(st.pop()),tostring(st.pop()) PA={a,b} st.push(a:match(b)) end\n  function instr.f_not(i,st)   local a = st.pop() st.push(not a) end\n  function instr.conc(i,st)    local b,a = st.pop(),st.pop() st.push(tostring(a) .. tostring(b)) end\n  function instr.neg(i,st)     local a = st.pop() PA={a} st.push(-a) end\n  function instr.t_today(i,st) local o = st.pop() PA={o} st.push(midnight()+o) end\n  function instr.t_next(i,st)  local t = st.pop() PA={t} t=t+midnight(); st.push(t >= os.time() and t or t+24*3600) end\n  function instr.t_plus(i,st)  local t = st.pop() PA={t} st.push(os.time()+t) end\n  function instr.gv(i,st)      \n    local name = i[3]; PA={name} st.push(marshallFrom(fibaro.getGlobalVariable(name)))\n  end\n  function instr.qv(i,st)      local name = i[3]; PA={name}   st.push(quickApp:getVariable(name)) end\n  function instr.pv(i,st)      local name = i[3]; PA={name}   st.push(quickApp:getVariable(name)) end\n  function instr.var(i,st,p)   local name = i[3]; PA={name}   st.push((p.env.get(name) or Script.get(name) or {})[1]) end\n  instr['local'] = function(i,st,p) local name = i[3]; PA={name} p.env.push(name,nil) end\n\n  function ER.returnMultipleValues(st,v0,...)\n    st.push(v0)\n    local args = {...}\n    for i=1,maxn(args) do st.push0(args[i]) end\n    return 'multiple_values' \n  end\n  \n  function instr.call(i,st,p)\n    local args = st.popm(i[4],true)\n    --if not next(args) then args={nil,0} end --hack to get around lua limits...\n    local name,f = i[3],nil\n    if name then \n      PA={name}\n      f = (p.env.get(name) or Script.get(name) or {})[1]\n      local mt = getmetatable(f)\n      if mt and mt.__call then local f0=f f = function(...) return mt.__call(f0,...) end end\n      if type(f)~=\"function\" then errorf(p,\"'%s' is not a function\",name) end\n    else \n      f = st.pop()\n      local mt = getmetatable(f)\n      if mt and mt.__call then local f0=f f = function(...) return mt.__call(f0,...) end end\n      if type(f)~=\"function\" then errorf(p,\"'%s' is not a function\",tostring(f)) end\n    end\n    local res = {pcall(f,table.unpack(args))}\n    if not res[1] then errorf(p,\"calling '%s' - %s\",name,res[2]) end\n    if res[2] == '%magic_suspend%' then  -- Ok, this is the way to signal that the fun is async...\n      local cb,msg = res[3],res[5]\n      p.yielded = true;\n      local timeout,tref = res[4] or settings.asyncTimeout,nil  -- default timeout in milliseconds\n      cb[1] = function(...)                     -- second value returned is a basket we put the callback function in\n        cb[2]=true\n        if tref == nil then return end          -- ignore callback if timeout has expired\n        Script.clearTimeout(p,tref)\n        ER.runCoroutine(p.co,nil,...)           -- no one interested in return result...\n      end\n      tref = Script.setTimeout(p,function() --  timeout handler\n        cb[2] = true\n        tref = nil\n        ER.runCoroutine(p.co,nil,nil,'%timeout%')\n        --p.co.options.error(fmt(\"Timeout for function '%s'\",name or tostring(f)))\n      end,\n      timeout) \n      st.push('%callback%'); return true -- ToDo add msg\n    end\n    st.push(res[2])\n    if #res > 2 then for i=3,#res do st.push0(res[i]) end end\n  end\n  \n  function instr.return0(i,st,p) st.push(nil) return true end\n  function instr.return1(i,st,p) \n    local s = st.popm(1) -- get ev. multiple values\n    if #s>1 then st.push(s) return 'multiple_values' else st.push(s[1]) return true end \n  end\n  function instr.returnm(i,st,p) st.push((st.popm(i[3],true))) return 'multiple_values' end\n  function instr.table(i,st)  -- Create table and push on stack\n    local keys = i[3]\n    local i,n = 1,#keys     -- ['%comp%','%value%',...] for computed indexes, [<key1>,<key2>,...] for named or integer indexes\n    local args = st.lift(n) -- Values on stack in same order as keys. Note that computed indexes have 2 consecutive entries on stack\n    local t = {}\n    while i <= n do\n      local k = keys[i]\n      if k == '%comp%' then\n        k = args[i]\n        i=i+1\n      end\n      t[k] = args[i]\n      i = i+1\n    end\n    st.push(t)\n  end\n  function instr.mvstart(i,st,p) p.mvs = p.mvs or {} p.mvs[i[3]] = st.size() end\n  function instr.mvend(i,st,p) \n    st.p2px()\n    local ss = p.mvs[i[3]]; \n    p.mvs[i[3]] = {ss,st.size()} \n  end\n  function instr.mv(i,st,p)\n    local tag,id,size = i[3],i[4],i[5]\n    local sf = p.mvs[tag]\n    local vp = sf[1]+id\n    -- st.dump()\n    -- print(sf[2],sf[1],id,vp,size)\n    local v = vp <= sf[2] and st.get(vp) or nil            -- get value from stack\n    if i[6] then p.mvs[tag] = nil st.setSize(sf[1]) end    -- last mv, trim away extra values\n    st.push(v)\n  end\n  \n  function instr.setvar(i,st,p) \n    local name,const,pop,v = i[3],i[4],i[5],nil\n    if const then v = copy(const[1]) if not pop then st.push(v) end\n  elseif pop then v=st.pop()\n  else v = st.peek() end\n  if p.env.set(name,v) then return end -- set in (rule) local environment\n  local flag,old = Script.set(name,v)   -- set in (rule) global environment\n  if flag and v~=old and triggerVars[name] then    -- trigger variable, emit event\n    local ev = eventCustomToString({type='trigger-variable',name=name,value=v,old=old})\n    Script.post(p,ev,0,\"trigger variable\")\n  end\nend\nfunction instr.setgv(i,st,p) \n  local name,const,pop,v = i[3],i[4],i[5],nil\n  if select(2,api.get(\"\/globalVariables\/\"..name)) == 404 then errorf(p,\"Global variable '%s' does not exist\",name) end\n  if const then \n    v = copy(const[1])\n    if not pop then st.push(v) end\n  elseif pop then v=st.pop()\n  else v = st.peek() end\n  fibaro.setGlobalVariable(name,marshallTo(v))\nend\nfunction instr.setqv(i,st,p) \n  local name,const,pop,v = i[3],i[4],i[5],nil\n  if const then \n    v = copy(const[1])\n    if not pop then st.push(v) end\n  elseif pop then v=st.pop()\n  else v = st.peek() end\n  quickApp:setVariable(name,v)\nend\nfunction instr.setpv(i,st,p) \n  local name,const,pop,v = i[3],i[4],i[5],nil\n  if const then \n    v = copy(const[1])\n    if not pop then st.push(v) end\n  elseif pop then v=st.pop()\n  else v = st.peek() end\n  quickApp:setVariable(name,v)\nend\nfunction instr.aref(i,st,p) \n  local key; if i[4] then key = i[4][1] else key = st.pop() end\n  local tab = st.pop()\n  if key == nil then errorf(p,\"key is nil for arrray index\") end\n  local tabtype = type(tab)\n  if tabtype ~= 'table' and tabtype ~= 'userdata' and tabtype ~= 'string' then errorf(p,\"table is '%s' for array reference\",tabtype) end\n  ---@diagnostic disable-next-line: need-check-nil\n  st.push(tab[key])\n  if i[5] then st.push(tab) end -- for callobj\nend\nfunction instr.aset(i,st,p)\n  local key,const,pop,var,v = i[3],i[4],i[5],i[6],nil\n  if const then v = copy(const[1]) else v = st.pop() end\n  if key==nil then key = st.pop() end\n  if key == nil then errorf(p,\"key is nil for array index\") end\n  local tab = st.pop()\n  local tabtype = type(tab)\n  if tabtype ~= 'table' and tabtype ~= 'userdata' then errorf(p,\"table is '%s' for array reference\",tabtype) end\n  tab[key] = v\n  if not pop then st.push(v) end\nend\nfunction instr.eventm(i,st,p)\n  local env = p.args[1]\n  st.push(i[3]==env.evid or env.evid=='%%START%%')\nend\nfunction instr.prop(i,st,p)\n  local ids,prop,env = st.pop(),i[3],p.co and p.co._env or p.args[1] or {}\n  local isTable,n,mapf,v = type(ids) == 'table',1,nil,nil\n  if isTable then n = maxn(ids) end\n  if ids==nil or n == 0 then errorf(p or env,\"No devices found for :%s\",prop) end\n  local function itemFun(e) \n    local dev = ER.getDeviceObject(e)\n    if not dev then errorf(p,\"%s is not a valid device\",tostring(dev)) end\n    if not dev:isProp(prop) then errorf(p,\":%s is not a valid device property for %s\",prop,dev) end\n    return dev.getProp[prop](dev,prop,env.event or {},ER.propHelpers)\n  end\n  if ER.propFilters[prop] then\n    local filter = ER.propFilters[prop]\n    ids = isTable and ids or {ids}\n    st.push(filter(ids,env.event or {}))\n    return\n  end\n  if isTable then\n    local dev0 = ER.getDeviceObject(ids[1]) -- first item decides map function\n    local mapf = dev0 and dev0.map[prop] or function(f,l) local r={} for i=1,n do r[#r+1]= f(l[i]) end return r end\n    v = mapf(itemFun,ids)\n  else v = itemFun(ids) end\n  st.push(v)\nend\n\nfunction instr.putprop(i,st,p)\n  local value,ids,prop = st.pop(),st.pop(),i[3]\n  local env = p.co and p.co._env or p.args[1] or {}\n  local isTable,n,v = type(ids) == 'table',1,nil\n  if isTable then n = maxn(ids) end\n  if ids==nil or n == 0 then errorf(env or p,\"No devices found for :%s\",prop) end\n  local function itemFun(e,v) \n    local dev = ER.getDeviceObject(e)\n    if not dev then errorf(p,\"%s is not a valid device\",tostring(dev)) end\n    if not dev.setProp[prop] then errorf(p,\":%s is not a valid device set property for %s\",prop,dev) end\n    return dev.setProp[prop](dev,prop,v,ER.propHelpers)\n  end\n  if isTable then\n    v = {}\n    if type(value) == 'table' and #value == n then\n      for i=1,n do v[#v+1] = itemFun(ids[i],value[i]) end\n    else\n      for i=1,n do v[#v+1] = itemFun(ids[i],value) end\n    end\n  else v = itemFun(ids,value) end\n  st.push(v)\nend\n\nfunction instr.betw(i,st,p)\n  local t2,t1,time=tonumber(st.pop()),tonumber(st.pop()),os.time()\n  if t1 == nil then errorf(p,\"Bad first argument to between '..' - not a number\") end\n  if t2 == nil then errorf(p,\"Bad second argument to between '..' - not a number\") end\n  if t1  > 24*60*60 then\n    st.push(t1 <= time and t2 >= time)\n  else\n    local midnight = midnight()\n    local now = time-midnight\n    --print(os.date(\"%H:%M:%S\",t1+midnight),os.date(\"%H:%M:%S\",time),os.date(\"%H:%M:%S\",t2+midnight))\n    if t1<=t2 then st.push(t1 <= now and now <= t2) else st.push(now >= t1 or now <= t2) end \n  end\nend\nfunction instr.betwo(i,st) end\nfunction instr.daily(i,st,p) \n  local env = p.co and p.co._env or p.args[1]\n  st.push(env.evid=='%%START%%' or (env.event.type == 'daily' and env.event.id == env.rule.id))\nend\nfunction instr.interv(i,st,p)\n  local t = math.abs(st.pop())\n  Script.post(p,{type='%interval%',id=p.rule.id,_sh=true},t,'@@')\n  st.push(true)\nend\nfunction instr.addto(i,st) local v = st.pop(); PA={v}; st.push(v+i[3]) end\nfunction instr.subto(i,st) local v = st.pop(); PA={v}; st.push(i[4] and v-i[3] or i[3]-v) end\nfunction instr.multo(i,st) local v = st.pop(); PA={v}; st.push(v*i[3]) end\nfunction instr.divto(i,st) local v = st.pop(); PA={v}; st.push(i[4] and v\/i[3] or i[3]\/v) end \nfunction instr.modto(i,st) local v = st.pop(); PA={v}; st.push(i[4] and v%i[3] or i[3]%v) end\n\n--function instr.redaily(i,st)      st.push(Rule.restartDaily(st.pop())) end\nfunction instr.eval(i,st)           st.push(ER.eval(st.pop(),{silent=true})) end\n\nfunction instr.rule(i,st,p) st.push(ER:createRule(i[3],i[4],p)) end\nfunction instr.rule_action(i,st,p) -- Bridges condition and action, calls coroutines action handler (for logging etc)\n  local cond = st.popm(1)\n  if cond[1] then\n    p.co._action(true,cond[2])\n  else\n    p.co._action(false,cond[2])\n    st.push(false)\n    return true\n  end \nend\n\n---------------------------------------------------------------------------------------------------\n-- setup debug formats for instructions\nfor i,_ in pairs(instr) do ilog[i] = \"%s\/%s\" end\nfor i,n in pairs({\n  push=1,var=1,gv=1,qv=1,pv=1,jmp=1,jmpf=1,jmpt=1,jmpfp=1,jmpfip=1,jmpp=1,eventm=1,prop=1,mvstart=1,mvend=1,\n  setvar=3,aset=3,call=1,callexpr=1,callobj=1,collect=2,mv=4,aref=1,addto=2,subto=2,multo=2,divto=2,modto=2,['local']=1,\n  setgv=3,setqv=3,setpv=3,\n}) do ilog[i] = \"%s\/%s \"..string.rep(\"%s\",n,\" \") end\n\n-- setup error handlers for instructions\nfor _,i in ipairs({'add','sub','mul','div','mod'}) do\n  errh[i] = function(i) \n    if not tonumber(PA[1]) then return fmt(\"%s expected number as first argument, got %s\",i,type(PA[1])) end\n    if not tonumber(PA[2]) then return fmt(\"%s expected number as second argument, got %s\",i,type(PA[2])) end\n  end\nend\nfor _,i in ipairs({'addto','subto','multo','divto','modto','neg'}) do\n  errh[i] = function(i) \n    if not tonumber(PA[1]) then return fmt(\"%s expected number as first argument, got %s\",i,type(PA[1])) end\n  end\nend\nfor _,i in ipairs({'call','callexpr','callobj',}) do\n  errh[i] = function(i,err)\n    local name = PA[1]\n    if not (name and _G[name]) then return fmt(\"undefined function %s\",tostring(name)) end\n    return fmt(\"error executing function %s - %s\",name,err)\n    end\n  end\n  ------------- VM -------------\n  local function encodeArgs(t) \n    local r={} for _,v in ipairs(t) do r[#r+1]=type(v)=='table' and encodeFast(v) or v end return table.unpack(r) \n  end\n  local function instr2str(i)\n    local s = i[1]\n    local str = ilog[i[1]] or \"%s\/%s\"\n    local args = {encodeArgs(i)}\n    return fmt(ilog[i[1]] or \"%s\/%s\",encodeArgs(i))\n  end\n  \n  local function traceInstr(pc,i,size,oldValue,newValue)\n    return fmt(\"PC:%03d ST:%02d %-20s %s->%s\",pc,size,instr2str(i),encodeFast(oldValue):sub(1,20),encodeFast(newValue):sub(1,20))\n  end\n  \n  local function run2(fun,rtd,...)\n    if rtd._inited then ER.returnMultipleValues(rtd.stack,table.unpack(rtd.args or {})) \n    else\n    for _,v in ipairs({...}) do rtd.stack.push0(v) end\n    end\n    local code,codeLen = fun.code,#fun.code\n    local p,st = rtd,rtd.stack\n    local stat,res\n    local trace = rtd.trace or fun.trace\n    while p.pc <= codeLen and stat==nil do\n      local i = code[p.pc]\n      if trace then\n        local prevStack,pc2,ss = st.peek(),p.pc,st.size()\n        stat,res = instr[i[1]](i,st,p)\n        Script.print(traceInstr(pc2,i,ss,prevStack,st.peek()))\n      else\n        stat,res = instr[i[1]](i,st,p)\n      end\n      p.pc = p.pc+1\n    end\n    stat = stat==nil and true or stat\n    return stat,table.unpack((st.popm(1)))\n  end\n  \n  local function run(fun,rtd,...)\n    ER.runningFun = fun\n    ER.runningRule = rtd.rule\n    rtd.args = {...}\n    rtd.fun = fun\n    local stat = {e_pcall(run2,fun,rtd,...)}\n    if not stat[1] then\n      if isErrorMsg(stat[2]) then e_error(stat[2]) end\n      local pc = rtd.pc\n      local i = fun.code[pc]\n      local dbg = fun.dbg[i]\n      local err = errh[i[1]] and errh[i[1]](i[1],stat[2]) or (stat[2]..\" \"..i[1])\n      local d = dbg and dbg.d or {}\n      ER.runningFun,ER.runningRule = nil,nil\n      e_error(errorMsg{type=\"Runtime\",msg=err,from=d.from,to=d.to,rule=rtd.rule,src=fun.src})\n    end\n    --assert(rtd.stack.size()==0,\"stack not empty\")\n    ER.runningFun,ER.runningRule = nil,nil\n    --if rtd.trace or fun.trace then print(fmt(\"Exit:%s %s\",rtd.stack.size(),json.encode(stat))) rtd.stack.dump() end\n    if stat[2] == true then return table.unpack(stat,3) end\n    if stat[2] == 'multiple_values' then return table.unpack(stat[3]) end\n  end\n  \n  function ER:addInstr(name,fn,log)\n    instr[name] = fn\n    ilog[name] = log or \"%s %s\"\n  end\n  \n  function ER:createFun(codestr,options)\n    options = options or {}\n    local fun = {\n      code = codestr.code,\n      dbg = codestr.dbg,\n      src = codestr.src,\n      name = codestr.name,\n    }\n    function fun:run(rtd,...)\n      rtd = rtd or {\n        pc = 1,\n        stack = stack(),\n        env = Environment(), -- local vars\n      }\n      return run(self,rtd,...) \n    end\n    \n    function fun.codeList()\n      local res = {}\n      for pc,i in pairs(fun.code) do\n        res[#res+1] = fmt(\"%03d: %s\",pc,instr2str(i))\n      end\n      return table.concat(res,\"\\n\")\n    end\n    setmetatable(fun,{\n      __call=function(... ) return fun:run(nil,...) end,\n      __tostring=function(f) return fmt(\"[fun %s,size:%s]\",f.name,#f.code) end\n    })\n    return fun\n  end\n  \n  --------- ER coroutine support ---------\n  -- works like Lua coroutines\n  \n  ER.coroutine = {}\n  function ER.coroutine.create(efun)\n    local co = {\n      fun = efun,\n      status = 'suspended',\n      rtd = {\n        pc = 1,\n        stack = stack(),\n        env = Environment(),\n        _inited = false,\n      }\n    }\n    setmetatable(co,{\n      __tostring=function(co) return fmt(\"[co %s,pc:%s,st:%s]\",co.fun,co.rtd.pc,co.rtd.stack.size()) end\n    })\n    return co\n  end\n  function ER.coroutine.status(co) return co.status end\n  function ER.coroutine.resume(co,...)\n    if co.status =='dead' then return false,\"cannot resume dead coroutine\" end\n    co.status = 'running'\n    local stat = {e_pcall(run,co.fun,co.rtd,...)}\n    if stat[1] == false then\n      co.status = 'dead'\n      return false,stat[2]\n    end\n    if co.rtd.yielded then\n      co.status = 'suspended'\n      co.rtd.yielded = false\n      co.rtd._inited = true\n    else\n      co.status = 'dead'\n    end\n    return true,table.unpack(stat,2)\n  end\n  \n  --function ER.coroutines.yield(...) end -- only called from within code\n  \nend","isMain":false},{"isOpen":false,"type":"lua","name":"rule","content":"fibaro.__ER  = fibaro.__ER or { modules={} }\n\nfunction fibaro.__ER.modules.rule(ER)\n  \n  local stack,stream,errorMsg,isErrorMsg,e_error,e_pcall,errorLine,\n  marshallFrom,marshallTo,toTime,midnight,encodeFast,argsStr,eventStr,\n  PrintBuffer,sunData,LOG,LOGERR,htmlTable,evOpts,eventCustomToString =\n  table.unpack(ER.utilities.export)\n\n  local settings,debug = ER.settings,ER.debug\n\n  local ruleID,rules = 0,{}\n  ER.rules,ER.ruleID = rules,0\n  local Rule = ER.Rule\n  local stdPropObject,isPropObject = ER.stdPropObject,ER.isPropObject\n  local htmlTable = ER.utilities.htmlTable\n  \n  local fmt=string.format\n  local function hms(t) return os.date(\"%H:%M:%S\",t < 24*3600 and t+fibaro.midnight() or t) end -- TBD: move to Utils.lua\n  local vars,triggerVars = ER._vars,ER._triggerVars\n  local function now() local t = os.date(\"*t\") return t.hour*3600+t.min*60+t.sec end\n\n  ER.ruleStats = {runs=0,errors=0,successes=0,fails=0,last={}}\n  local ruleStats = ER.ruleStats\n\n  local tableOpts = {table=\"width='100%' border=1 bgcolor='\"..settings.listColor..\"'\",td=\"align='left'\"}\n  local tableOptUI = {table=\"width='100%' border=1 bgcolor='white'\",td=\"align='left'\"}\n\n\n  function ER.createRuleStats(htmlTable,len,opts)\n    opts = opts or tableOpts\n    len = len or 100\n    local pr = PrintBuffer()\n    pr:printf(\"Invocations: %s\",ER.ruleStats.runs)\n    pr:printf(\"Sucesses: %s\",ER.ruleStats.successes)\n    pr:printf(\"Fails: %s\",ER.ruleStats.fails)\n    pr:printf(\"Errors: %s\",ER.ruleStats.errors)\n    pr:add((\"-\"):rep(75))\n    pr:add(\"Recent rules:\")\n    for i=1,len do\n      local c = ER.ruleStats.last[i]\n      if not c then break end\n      pr:printf(\"%s %s (%s,%s)\",os.date(\"%H:%M:%S\",c.start),c.name,c.status,os.date(\"%H:%M:%S\",c.time))\n    end\n    return htmlTable({pr:tostring()},opts)\n  end\n\n  local function addRuleStats(c) table.insert(ruleStats.last,1,c) end\n\n  function ER.listRuleStats() LOG(ER.createRuleStats(htmlTable)) end\n  local function updateRuleStats()\n    local pr = PrintBuffer('<p align=\"left\">')\n    pr:printf(\"Invocations: %s\",ER.ruleStats.runs)\n    pr:printf(\"Sucesses: %s\",ER.ruleStats.successes)\n    pr:printf(\"Fails: %s\",ER.ruleStats.fails)\n    pr:printf(\"Errors: %s\",ER.ruleStats.errors)\n    pr:add((\"-\"):rep(75))\n    for i=1,10 do\n      local c = ER.ruleStats.last[i]\n      if not c then break end\n       pr:printf(\"%s %s (%s,%s)\",os.date(\"%H:%M:%S\",c.start),c.name,c.status,os.date(\"%H:%M:%S\",c.time))\n    end\n    pr:add(\"<\/p>\")\n    quickApp:updateView(\"stats\",\"text\",pr:tostring())\n  end\n\n  function ER.listRules(extended)\n    local pr,n = PrintBuffer(),0\n    pr:printf(\"Rules:\")\n    for i,r in pairs(rules) do\n      n = n+1\n      if extended then\n        pr:printf(\"%s\",r.description)\n      else\n        pr:printf(\"%d:%-60s [%s]\",i,r.longName,r._enabled and \"enabled\" or \"disabled\")\n      end\n    end \n    pr:printf(\"Number of rules: %d\",n)\n    LOG(htmlTable({pr:tostring()},tableOpts))\n  end\n\n  function ER.listTimers()\n    local pr,n = PrintBuffer(),0\n    local timers = {}\n    pr:printf(\"Timers:\")\n    for id,r in pairs(rules) do\n      for _,t in pairs(r._timers) do\n        local time = t[2]\n        timers[time] = timers[time] or {}\n        timers[time][#timers[time]+1] = fmt(\"%s%s\",t[1],r)\n      end\n      for _,t in pairs(r._dailyTimers) do\n        local time = t[2]\n        timers[time] = timers[time] or {}\n        timers[time][#timers[time]+1] = fmt(\"@%s\",r)\n      end\n    end\n    for time,rs in pairs(timers) do\n      pr:print(hms(time),\"->\",table.unpack(rs))\n    end\n    LOG(htmlTable({pr:tostring()},tableOpts))\n  end\n  \n  function ER.listVariables(name)\n    name = name or \".*\"\n    local pr,n = PrintBuffer(),0\n    pr:printf(\"Variables:\")\n    for vn,v in pairs(vars) do\n      if vn:match(name) then\n        pr:printf(\"%s = %s\",vn,encodeFast(v) \/\/ settings.truncLog)\n        n = n+1\n      end\n    end \n    pr:printf(\"Number of variables: %d\",n)\n    LOG(htmlTable({pr:tostring()},tableOpts))\n  end\n  \n  -- {prop='value',operator='eq',value='value'}\n  -- {gv='value',operator='eq',qv='value'}\n  -- {qv='value',operator='eq',qv='value'}\n  -- {event='value',operator='eq',qv='value'}\n  -- {triggerVar='value',operator='eq',event='value'}\n  -- {betw={from='value',to='value'},event='value'}\n  -- {daily={from='value',to='value'},event='value'}\n  -- {interv={from='value',to='value'},event='value'}\n  \n  local triggerHandlers={}\n  \n  local function compute(p,opts) local c = ER:compile(p,opts) return c() end\n  local function compile(p,opts) return ER:compile(p,opts) end\n  \n  local function errorf(rule,tk,fm,...)\n    if tk.d then tk = tk.d end\n    local err = errorMsg{type=\"Rule\",msg=fmt(fm,...),from=tk.from,to=tk.to,rule=rule,src=rule.src}\n    e_error(err) \n  end\n  \n  local CATCHUP = math.maxinteger\n  \n  local userDeviceObjects = {}\n  local function getDeviceObject(id)\n    local f = tonumber(id)\n    if f then stdPropObject.id = id return userDeviceObjects[f] or stdPropObject end\n    if isPropObject(id) then return id end\n  end\n  ER.getDeviceObject = getDeviceObject\n  local getTriggers\n\n  function triggerHandlers.prop(p,t)\n    getTriggers(p.args[1],t)\n    local ids,ids2 = compute(p.args[1],t.opts),{}\n    local prop,isTable,tn = p.args[2],false,0\n    if ER.propFilters[prop] then\n      if not ER.propFilterTriggers[prop] then return  -- filters don't generate triggers themselfs...\n      else                                            -- unless they are marked as triggerGenerators, like GV and QV\n        local v = compute(p,t.opts)\n        getTriggers(v,t)\n      end\n    end\n    if type(ids) == 'table' then isTable = true else ids = {ids} end\n    local n = table.maxn(ids)\n    if n == 0 then errorf(t.opts.rule,p.args[1],\"No devices found for :%s, must be defined when rule is defined\",prop) end\n    for i = 1,n do\n      local dev = getDeviceObject(ids[i])\n      ids2[i] = {dev,ids[i]}\n      if not dev then errorf(t.opts.rule,p,\"%s is not a valid device\",tostring(dev)) end\n      if not dev:isProp(prop) then errorf(t.opts.rule,p,\":%s is not a valid device property\",prop) end\n      tn = tn + (dev:isTrigger(prop) and 1 or 0)\n    end\n    if tn == 0 then return end -- no triggers, ignore\n    for _,id in ipairs(ids2) do\n      local s = tostring(id[2])\n      local tr = id[1]:getTrigger(id[2],prop)\n      local trk = encodeFast(tr) \n      --t.srct[prop..tostring(id[2])] = tr\n      t.srct[trk] = tr\n    end\n  end\n  function triggerHandlers.var(p,t) \n    if triggerVars[p.name] then \n      local evn = \"TV:\"..p.name\n      if t.cd then t.dt[evn] = true end\n      t.srct[evn]={type='trigger-variable', name=p.name} \n    end\n  end\n  function triggerHandlers.gv(p,t) \n    local evn = \"GV:\"..p.name\n    if t.cd then t.dt[evn] = true end\n    t.srct[evn]={type='global-variable', name=p.name} \n  end\n  function triggerHandlers.qv(p,t) \n    local evn = \"QV:\"..p.name\n    if t.cd then t.dt[evn] = true end\n    t.srct[evn]={type='quickvar', name=p.name} \n  end\n  local eid = 0\n  function triggerHandlers.table(p,t)\n    getTriggers(p.value,t)\n    local ev = compute(p,t.opts)\n    if ev.type then eid = eid+1 t.srct[\"EV:\"..eid]=compute(p,t.opts) end\n  end\n  function triggerHandlers.const(p,t)\n    ---@diagnostic disable-next-line: undefined-field\n    if type(p.value)=='table' and p.value.type then \n      local evid = \"EV:\"..eid\n      eid = eid+1 t.srct[evid]=p.value\n      p.type = 'eventm'\n      p.evid = evid\n      p.event = p.value\n      p.value = 0\n    end\n  end\n  function triggerHandlers.betw(p,t)\n    t.cd = true\n    getTriggers(p.args,t)\n    t.cd = false\n    t.timers[#t.timers+1] = compile(p.args[1],t.opts); \n    t.timers[#t.timers+1] = compile({type='op',op='add',args={{type='num',value=1,},p.args[2]}},t.opts) \n  end\n  function triggerHandlers.daily(p,t)   -- collect daily expressions, @10:00, @{$mytime,$othertime+10:00}\n    if t.daily~=nil then errorf(t.opts.rule,p,\"Only one @daily in a rule is supported\") end\n    t.cd = true\n    getTriggers(p.args[1],t)\n    t.cd = false\n    t.daily = compile(p.args[1],t.opts)\n    local times,n = t.daily(),0\n    if type(times) == 'table' then\n      for _,time in ipairs(times) do\n        if time == CATCHUP then t.catchup = true else n=n+1 end\n      end\n      if n < 1 then errorf(t.opts.rule,p,\"No valid times in @daily expression\") end\n    end\n  end \n  function triggerHandlers.interv(p,t)  -- collect interval expressions, @@00:05, @{$mytime,$othertime+00:01}\n    if t.interv~=nil then errorf(t.opts.rule,p,\"Only one @@interval in a rule is supported\") end\n    t.interv = compile(p.args[1],t.opts)\n  end\n  \n  function getTriggers(p,t)\n    if type(p) == 'table' then\n      if p[1] then \n        for _,v in ipairs(p) do getTriggers(v,t) end\n      else\n        local h = triggerHandlers[p.type] or triggerHandlers[p.op or \"\"]\n        if h then h(p,t)\n        else \n          for _,v in pairs(p) do getTriggers(v,t) end \n        end\n      end\n    end\n  end\n  \n  local function setupDailys(rule,catchup)\n    rule._clearDailyTimers()  -- clear any previous outstanding daily timer\n    local scheduled,n = {},now()\n    for _,texpr in ipairs(rule.dailys) do\n      local v = texpr() v = type(v)=='table' and v or {v}\n      local flag = false\n      for _,t in ipairs(v) do\n        if not tonumber(t) then errorf(rule,{},\"Invalid daily time: %s\",tostring(t)) end\n        if t < n and rule.catchup and catchup then -- time passed and catchup is on\n          rule._addDailyTimer(0,t)               -- run rule \n          catchup = false                        -- but only once\n        elseif t >= n and t ~= CATCHUP then      -- schedule timer for later\n          if not scheduled[t] then               -- Don't schedule same timer twice\n            scheduled[t] = true\n            rule._addDailyTimer(t-n,t)\n          end\n        end\n      end\n    end\n  end\n  \n  ER.midnightScheduler(function()  -- Reschedule all dailys at midnight\n    for _,rule in pairs(rules) do\n      if rule.isEnabled() then\n        setupDailys(rule,true)\n      end\n    end\n  end)\n\n  local function printInfo(rule)\n    local s = {fmt(\"%s info:\",rule.rname)} for k,t in pairs(rule.triggers) do s[#s+1] = \"->Event:\"..eventStr(t) end\n    for _,t in ipairs(rule.dailys) do\n      local v = t()\n      if type(v)=='table' then \n        for _,t in ipairs(v) do if t ~= math.maxinteger then s[#s+1] = fmt(\"->Dailys:%s\",hms(t)) end end\n      else s[#s+1] = fmt(\"->Timer:%s\",hms(v)) end\n    end\n    for _,t in pairs(rule._timers) do\n      s[#s+1] = fmt(\"->Timer:%s%s\",t[1],hms(t[2]))\n    end\n    for _,t in pairs(rule._dailyTimers) do\n      s[#s+1] = fmt(\"->Timer:@%s\",hms(t[2]))\n    end\n    return LOG(table.concat(s,\"\\n\"))\n  end\n  local function printProcesses(rule)\n    local res = {}\n    if not next(rule.runners) then\n      res = {fmt(\"%s processes: No processes running\",rule.rname)}\n    else\n      res = {fmt(\"%s processes:\",rule.rname)}\n      for co,stat in pairs(rule.runners) do res[#res+1]= fmt(\"%s => %s (%s)\",rule.rname,stat,co) end\n    end\n    return LOG(table.concat(res,\"\\n\"))\n  end\n\n  local function nameRule(rule)\n    rule.rname = fmt(\"[Rule:%s]\",rule._name)\n    rule.longName = fmt(\"[Rule:%s:%s]\",rule._name,rule.src:gsub(\"[%s%c]+\",\" \") \/\/ settings.truncStr)\n  end\n\n  local function runRuleLogFun(co,rule,ok,event)\n    co.LOG(\"condition %s\",ok and \"true - action\" or \"false - cancelled\") \n  end\n\n  function ER:createRuleObject(options)\n    local rule = {type='%RULE%'}\n    ruleID = ruleID+1; ER.ruleID = ruleID\n    rule.id = ruleID\n    rule._name = options.name or tostring(rule.id)\n    rule._ltag = options.log \n    rule._rtag = options.tag \n    rule.src = options.src\n    nameRule(rule)\n    setmetatable(rule,{__tostring = function(rule) return rule.rname end})\n    return rule\n  end\n\n  function ER:createRule(cond,action,p)\n    local options = table.copyShallow(p.co.options or {})\n    local rule = options.rule\n    if rule==nil then errorf(rule,p,\"No rule object\") end\n    assert(rule)\n    options.rule = nil\n    rule.instance = 0\n    rule._enabled = true\n  \n    nameRule(rule)\n    \n    local triggers = { daily=nil, interv=nil, timers={}, srct={}, dt = {}, opts = { src = rule.src, rule = rule } }\n    getTriggers(cond,triggers)\n    local trs = triggers.srct\n    \n    rule.triggers = trs\n    rule.catchup = triggers.catchup\n    rule.dailys = {}          -- daily times and between times\n    rule._dailyTimers = {}    -- refs to emitted daily timers (for cancellation)\n    rule._timers = {}         -- refs to emitted timers, ex posts (for cancellation)\n    rule.evhandlers = {}\n    \n    rule.fun = compile({type='rule_action',cond=cond,action=action},triggers.opts)\n    \n    if not (next(trs) or triggers.daily or triggers.interv or #triggers.timers>0) then errorf(rule,cond,\"No triggers in rule\") end\n    if not (not(triggers.daily and triggers.interv)) then errorf(rule,cond,\"Only one @daily or @@interval in a rule is supported\") end\n    \n    local dailys = triggers.timers\n    if triggers.daily then table.insert(dailys,1,triggers.daily) end\n    rule.dailys = dailys\n    \n    if triggers.interv then\n      if options.ruleTrigger==nil then options.ruleTrigger=false end\n      local ev = {type='%interval%',id=rule.id,_sh=true}\n      local fun = function(env) return rule.start0(env.event,nil,env.p) end\n      local handler = fibaro.event(ev,fun)\n      rule.evhandlers[ev] = {fun,handler}\n      rule.autostart = function()\n        local t,delay = triggers.interv(),0\n        if t < 0 then t=-t delay = (os.time() \/\/ t + 1)*t - os.time() end\n        setTimeout(function() rule._post(ev,delay,\"@@\") end,0)\n        return rule\n      end\n      if rule._enabled then rule.autostart() end\n    else -- interval trigger disables all other triggers for rule\n      for evid,t in pairs(trs) do\n        local fun = function(env) \n          if triggers.dt[evid] then rule._setupDailys(false) end\n          return rule.start0(env.event,evid,env.p) \n        end\n        local handler = fibaro.event(t,fun)\n        rule.evhandlers[t] = {fun,handler}\n      end\n    end\n\n    -- public rule functions\n    function rule.start(...) local args = {...} setTimeout(function() rule.start0(table.unpack(args)) end,1) return rule end\n    function rule.name(name) rule._name = name; nameRule(rule) return rule end\n    function rule.tag(tag) rule._rtag = tag; return rule end\n    function rule.log(tag) rule._ltag = tag; return rule end\n    function rule.mode(mode) rule._mode = mode; return rule end -- 'killOthers', 'killSelf'\n    function rule.enable() \n      if rule._enabled then return end \n      if not evOpts(options.silent,debug.silent,false) then LOG(\"%s %s\",ER.color(\"lightgreen\",\"Enabled\"),rule.rname) end\n      rule._enabled = true\n      for _,eh in pairs(rule.evhandlers) do eh[2].enable() end\n      return rule.autostart and rule.autostart() or rule\n    end\n    function rule.disable()\n      if not rule._enabled then return end\n      if not evOpts(options.silent,debug.silent,false) then LOG(\"%s %s\",ER.color(\"salmon\",\"Disabled\"),rule.rname) end\n      rule._enabled = false\n      rule.stop()\n      for _,eh in pairs(rule.evhandlers) do eh[2].disable() end\n      return rule \n    end\n    function rule.isEnabled() return rule._enabled end\n    function rule.print() print(self) return rule end\n    function rule.delete()\n      rule.disable()\n      for event,eh in pairs(rule.evhandlers) do\n        fibaro.removeEvent(event,eh[1])\n      end\n      rules[rule.id] = nil\n    end\n    function rule.stop()\n      rule._clearDailyTimers() \n      rule._clearTimers() \n      return rule\n    end\n    function rule.processes() printProcesses(rule) return rule end\n    function rule.info() printInfo(rule) return rule end\n\n    function rule.recompile() -- recompile rule code, replacing old rule with new rule\n      rule.stop()\n      local nr = rule.compile(rule.src,triggers.opts)\n      local nrid = nr.id\n      nr._trace = rule._trace\n      nr.id = rule.id\n      nr.name = rule.name\n      rules[rule.id] = nr\n      rules[nrid] = nil\n    end\n    ------------------- public rule variables ----------------------\n    -- rule.trace = boolean        -- if true, trace rule execution (VM)\n    -- rule.id = number            -- assigned by ER when rule is created\n    -- rule.tag = <string>         -- allows for grouping rules (ex. for enable\/disable)\n    -- rule.rname = <string>       -- \"[Rule:<id>:_name]\"\n    -- rule.longName = <string>    -- \"[Rule:<id>:_name:<short source>]\"\n    -- rule.description = <string> -- shortName + triggers\n    -- rule.info = <string>        -- shortName + current timers\n    -- rule.src = <string>         -- rule source definition\n    -- rule.code == <string>       -- compiled rule code\n    \n    rule.runners = {}\n    local coroutine = ER.coroutine \n    local runCoroutine = ER.runCoroutine\n\n    function rule.start0(ev,id,vars)\n      ev = ev or {type='start'}\n      ruleStats.runs = ruleStats.runs + 1\n      rule.last = os.time()\n      --if rule._mode == 'killOthers' then rule.stop() -- moved to success\/fail\n      --elseif\n      if rule._mode == 'killSelf' and  next(rule.runners) then return rule end\n\n      if not getmetatable(ev) then eventCustomToString(ev) end \n\n      local co = coroutine.create(rule.fun)\n      rule.instance = rule.instance+1\n      local instname = fmt(\"[Rule:%s:%s]\",rule._name,rule.instance)\n      co.name = setmetatable({},{__tostring = function() return instname end})\n      co.rtd.rule = rule\n      rule.runners[co] = 'running'\n      co._stats = { name = co.name }\n      co._stats.status,co._stats.time = 'started',os.time(); updateRuleStats()\n      co._stats.start = os.time()\n      addRuleStats(co._stats)\n      if #ruleStats.last > 80 then table.remove(ruleStats.last,81) end -- keep last 10\n\n      local env = {event=ev,evid=id or '%%START%%',vars=vars,rule=rule,name=co.name,co=co,instance=rule.instance}\n      local locals = co.rtd.env -- local variables\n      locals.push('env',env)\n      for k,v in pairs(vars or {}) do locals.push(k,v) end\n      \n      local conditionSucceeded = false\n      function co._action(ok,msg)\n        conditionSucceeded = ok\n        co._stats.status,co._stats.time = \"true\" or \"fail\",os.time(); updateRuleStats()\n        if ok then ruleStats.successes = ruleStats.successes + 1\n          if rule._mode == 'killOthers' then rule.stop() end\n        else ruleStats.fails = ruleStats.fails + 1 end\n\n        local log = false\n        if ok then log = evOpts(options.ruleTrue,debug.ruleTrue)\n        else log = evOpts(options.ruleFalse,debug.ruleFalse) end\n        if log then\n          local logf = options.runRuleLogFun or settings.runRuleLogFun or runRuleLogFun\n          logf(co,rule,ok,ev)\n        end\n      end\n      function co.LOG(...) LOG(\"%s>> %s\",co.name,fmt(...)) end\n      function co.ERROR(...) \n        co._stats.status,co._stats.time = 'error',os.time(); updateRuleStats()\n        rule.errors=(rule.errors or 0)+1\n        ruleStats.errors = ruleStats.errors + 1\n        local errMsg = LOGERR(\"%s>> %s\",co.name,fmt(...))\n        fibaro.post({type='ERerror',id=rule.id,msg=errMsg,_sh=true})\n        if rule.errors > 2 then\n          rule.disable()\n          LOGERR(\"%s>> Too many errors (3), rule disabled\",co.name)\n        end\n      end\n\n      options.trace=rule._trace\n      options.debug=rule._debug\n      \n      local suspendMsg = {\n        ['%wait%'] = function(delay,msg) return fmt(\"wait %s %s\",hms(delay\/1000),msg or \"\") end,\n        ['%callback%'] = function(delay,msg) return msg or \"callback\" end,\n      }\n      \n      function options.suspended(typ,...)\n        co._stats.status,co._stats.time = 'suspended',os.time(); updateRuleStats()\n        rule.runners[co] = 'suspended'\n        local sm = suspendMsg[typ]\n        if sm then co.LOG(\"suspended %s - %s\",conditionSucceeded and \"action\" or \"triggered\",sm(...))\n        else\n          co.LOG(\"=> %s [%s,suspended]\",argsStr(typ,...),conditionSucceeded)\n        end\n      end\n      \n      function options.success(...)\n        rule.runners[co] = nil\n        co._stats.status,co._stats.time = conditionSucceeded and 'done' or 'fail',os.time(); updateRuleStats()\n        if evOpts(conditionSucceeded,options.ruleResult,debug.ruleResult) then co.LOG(\"result %s\",co.name,argsStr(...)) end\n        if rule.resultHook then rule.resultHook(conditionSucceeded,...) end\n      end\n      \n      function options.error(err) rule.runners[co] = nil co.ERROR(\"%s\",err) end\n      \n      if evOpts(options.ruleTrigger,debug.ruleTrigger) then co.LOG(\"triggered %s\",tostring(ev) \/\/ settings.truncStr) end\n      co._env = env\n      runCoroutine(co,options,env)\n      return rule\n    end -- start\n    \n    -- Internal rule housekeeping functions\n    function rule._setTimeout(fun,time,descr) \n      local ref = setTimeout(fun,time)\n      rule._timers[ref] = {descr or \"timer\",os.time()+time\/1000}\n      return ref\n    end\n    function rule._clearTimeout(ref)\n      local doc = rule._timers[ref]\n      if doc then clearTimeout(ref) end\n    end\n\n    --local function postLog(_,str) co.LOG(str) end\n\n    function rule._post(ev,time,descr,p)\n      local ref,t = nil,nil\n      ref,t = fibaro.post(ev,time,descr,function() if ref then rule._timers[ref]=nil end end,function(_,str) p.co.LOG(str) end)\n      if ref then \n        rule._timers[ref] = {descr or \"post\",t} \n      end\n    end\n    function rule._cancelPost(ref)\n      local doc = rule._timers[ref]\n      if doc then clearTimeout(ref) end\n    end\n    function rule._clearDailyTimers() \n      for t,_ in pairs(rule._dailyTimers) do clearTimeout(t) end\n      rule._dailyTimers = {}\n    end\n    function rule._clearTimers() \n      for ref,doc in pairs(rule._timers) do clearTimeout(ref) end\n      rule._timers = {}\n    end\n    function rule._addDailyTimer(delay,time)\n      local ref\n      LOG(\"%s>> scheduling %sdaily for %s\",rule.rname,delay==0 and \"and running\/catchup \" or \"\",hms(midnight()+time))\n      ref = setTimeout(function()\n        rule.start0({type='daily',id=rule.id,time=time})\n        rule._dailyTimers[ref]=nil\n      end,delay*1000)\n      rule._dailyTimers[ref]={'daily',time}\n    end\n    function rule._setupDailys(catch) setupDailys(rule,catch) end\n    \n    if #dailys>0 then rule._setupDailys(true) end\n    \n    function rule.evalPrint() nameRule(rule) if not options.silent then LOG(\"%s %s %s\",ER.color(\"lightgreen\",\"Defined\"),rule.rname,rule.src:gsub(\"\\n[%s%c]*\",\"\") \/\/ settings.truncLog) rule.evalPrint=nil end end\n\n    rules[rule.id] = rule\n    return rule\n  end\n  \nend","isMain":false},{"isOpen":false,"type":"lua","name":"builtins","content":"---@diagnostic disable: undefined-global\nfibaro.__ER  = fibaro.__ER or { modules={} }\n\nfunction fibaro.__ER.modules.builtins(ER)\n    \nlocal stack,stream,errorMsg,isErrorMsg,e_error,e_pcall,errorLine,\n  marshallFrom,marshallTo,toTime,midnight,encodeFast,argsStr,eventStr,\n  PrintBuffer,sunData,LOG,LOGERR,htmlTable,evOpts,eventCustomToString,eformat =\n  table.unpack(ER.utilities.export)\n    \n    local builtin = ER.builtins\n    local args = ER.builtinArgs\n    local Script = ER.Script\n    local defVars = ER.vars\n    local fmt = string.format\n    local settings = ER.settings\n\n    local definePropClass = ER.definePropClass\n    local PropObject = ER.PropObject\n    local function isEvent(e) return type(e) == 'table' and type(e.type)=='string' end\n\n    local function errorf(p,fm,...)\n        local dbg = p.fun.dbg[p.fun.code[p.pc]]\n        dbg = dbg and dbg.d or {}\n        local err = errorMsg{type=\"Runtime\",msg=fmt(fm,...),from=dbg.from,to=dbg.to,src=p.fun.src}\n        e_error(err)\n    end\n    \n    -------------- builtin constants -------------------------\n    ER.constants = {\n        ['_args'] = function(_,st,p) ER.returnMultipleValues(st,table.unpack(p.args or {})) end,\n        sunset = function(_,st) st.push(toTime(sunData().sunsetHour)) end,\n        sunrise = function(_,st) st.push(toTime(sunData().sunriseHour)) end,\n        midnight = function(_,st) st.push(midnight()) end,\n        catch = function(_,st) st.push(math.maxinteger) end,\n        dawn = function(_,st) st.push(toTime(sunData().dawnHour)) end,\n        dusk = function(_,st) st.push(toTime(sunData().duskHour)) end,\n        now = function(_,st) st.push(os.time()-midnight()) end,\n        wnum = function(_,st) st.push(fibaro.getWeekNumber(os.time())) end,\n        devices = function(_,st) st.push(fibaro.getDevicesID()) end,\n        quickapps = function(_,st) st.push(fibaro.getDevicesID({interfaces={'quickApp'}})) end,\n        quickvars = function(_,st) st.push(table.map(function(g) return g.name end,__fibaro_get_device_property(quickApp.id, \"quickAppVariables\").value or {})) end,\n        globals = function(_,st) st.push(table.map(function(g) return g.name end,api.get('\/globalVariables'))) end,\n        GW = function(_,st) st.push(api.get(\"\/home\")) end,\n    }\n\n    -------------- builtin props -------------------------\n    function ER.setupProps()\n        -- getProps helpers\n        local function BN(x) if type(x)=='boolean' then return x and 1 or 0 else return tonumber(x) or 0 end end\n        local function get(id,prop) return fibaro.get(id,prop) end\n        local function getnum(id,prop) return tonumber((fibaro.get(id,prop))) or nil end\n        local function on(id,prop) return BN(fibaro.get(id,prop)) > 0 end\n        local function off(id,prop) return BN(fibaro.get(id,prop)) == 0 end\n        local function call(id,cmd) fibaro.call(id,cmd); return true end\n        local function toggle(id,prop) if on(id,prop) then fibaro.call(id,'turnOff') else fibaro.call(id,'turnOn') end return true end\n        local function profile(id,_) return api.get(\"\/profiles\/\"..id) end\n        local function child(id,_) return quickApp.childDevices[id] end\n        local function last(id,prop) local _,t=fibaro.get(id,prop); local r = t and os.time()-t or 0; return r end\n        local function cce(id,_,e) return e.type=='device' and e.property=='centralSceneEvent'and e.id==id and e.value or {} end\n        local function ace(id,_,e) return e.type=='device' and e.property=='accessControlEvent' and e.id==id and e.value or {} end\n        local function sae(id,_,e) return e.type=='device' and e.property=='sceneActivationEvent' and e.id==id and e.value.sceneId end\n        local mapOr,mapAnd,mapF=table.mapOr,table.mapAnd,function(f,l,s) table.mapf(f,l,s); return true end\n        local function partition(id) return api.get(\"\/alarms\/v1\/partitions\/\" .. id) or {} end\n        local function armState(id) return id==0 and fibaro.getHomeArmState() or fibaro.getPartitionArmState(id) end\n        local function arm(id,action)\n            if action=='arm' then \n                local _,res = fibaro.armPartition(id); return res == 200\n            else\n                local _,res = fibaro.unarmPartition(id); return res == 200\n            end\n        end\n        local function tryArm(id)\n            local data,res = fibaro.tryArmPartition(id)\n            if res ~= 200 then return false end\n            if type(data) == 'table' then\n                fibaro.post({type='alarm',id=id,action='tryArm',property='delayed',value=data})\n            end\n            return true\n        end\n        local helpers = { BN=BN, get=get, on=on, off=off, call=call, profile=profile, child=child, last=last, cce=cce, ace=ace, sae=sae, mapOr=mapOr, mapAnd=mapAnd, mapF=mapF }\n        \n        local getProps={}\n        -- { type, function to get prop, property name in sourceTrigger, reduce function, if props is a rule trigger }\n        getProps.value={'device',get,'value',nil,true}\n        getProps.state={'device',get,'state',nil,true}\n        getProps.bat={'device',getnum,'batteryLevel',nil,true}\n        getProps.power={'device',getnum,'power',nil,true}\n        getProps.isDead={'device',get,'dead',mapOr,true}\n        getProps.isOn={'device',on,'value',mapOr,true}\n        getProps.isOff={'device',off,'value',mapAnd,true}\n        getProps.isAllOn={'device',on,'value',mapAnd,true}\n        getProps.isAnyOff={'device',off,'value',mapOr,true}\n        getProps.last={'device',last,'value',nil,true}\n    \n        getProps.armed={'alarm',function(id) return  armState(id)=='armed' end,'armed',mapOr,true}\n        getProps.tryArm={'alarm',tryArm,nil,'alarm',false}\n        getProps.isArmed={'alarm',function(id) return partition(id).armed end,'armed',mapOr,true}\n        getProps.isAllArmed={'alarm',function(id) return partition(id).armed end,'armed',mapAnd,true,true}\n        getProps.isDisarmed={'alarm',function(id) return partition(id).armed==false end,'armed',mapAnd,true}\n        getProps.isAnyDisarmed={'alarm',function(id) return partition(id).armed==false end,'armed',mapOr,true,false}\n        getProps.isAlarmBreached={'alarm',function(id) return partition(id).breached end,'breached',mapOr,true}\n        getProps.isAlarmSafe={'alarm',function(id) return partition(id).breached==false end,'breached',mapAnd,true}\n        getProps.isAllAlarmBreached={'alarm',function(id) return partition(id).breached end,'breached',mapAnd,true}\n        getProps.isAnyAlarmSafe={'alarm',function(id) return partition(id).breached==false end,'breached',mapOr,true,false}\n\n        getProps.child={'device',child,nil,nil,false}\n        getProps.parent={'device',function(id) return api.get(\"\/devices\/\"..id).parentId end,nil,nil,false}\n        getProps.profile={'device',profile,nil,nil,false}\n        getProps.scene={'device',sae,'sceneActivationEvent',nil,true}\n        getProps.access={'device',ace,'accessControlEvent',nil,true}\n        getProps.central={'device',cce,'centralSceneEvent',nil,true}\n        getProps.safe={'device',off,'value',mapAnd,true}\n        getProps.breached={'device',on,'value',mapOr,true}\n        getProps.isOpen={'device',on,'value',mapOr,true}\n        getProps.isClosed={'device',off,'value',mapAnd,true}\n        getProps.lux={'device',getnum,'value',nil,true}\n        getProps.volume={'device',get,'volume',nil,true}\n        getProps.position={'device',get,'position',nil,true}\n        getProps.temp={'device',get,'value',nil,true}\n        getProps.coolingThermostatSetpoint={'device',get,'coolingThermostatSetpoint',nil,true}\n        getProps.coolingThermostatSetpointCapabilitiesMax={'device',get,'coolingThermostatSetpointCapabilitiesMax',nil,true}\n        getProps.coolingThermostatSetpointCapabilitiesMin={'device',get,'coolingThermostatSetpointCapabilitiesMin',nil,true}\n        getProps.coolingThermostatSetpointFuture={'device',get,'coolingThermostatSetpointFuture',nil,true}\n        getProps.coolingThermostatSetpointStep={'device',get,'coolingThermostatSetpointStep',nil,true}\n        getProps.heatingThermostatSetpoint={'device',get,'heatingThermostatSetpoint',nil,true}\n        getProps.heatingThermostatSetpointCapabilitiesMax={'device',get,'heatingThermostatSetpointCapabilitiesMax',nil,true}\n        getProps.heatingThermostatSetpointCapabilitiesMin={'device',get,'heatingThermostatSetpointCapabilitiesMin',nil,true}\n        getProps.heatingThermostatSetpointFuture={'device',get,'heatingThermostatSetpointFuture',nil,true}\n        getProps.heatingThermostatSetpointStep={'device',get,'heatingThermostatSetpointStep',nil,true}\n        getProps.thermostatFanMode={'device',get,'thermostatFanMode',nil,true}\n        getProps.thermostatFanOff={'device',get,'thermostatFanOff',nil,true}\n        getProps.thermostatMode={'device',get,'thermostatMode',nil,true}\n        getProps.thermostatModeFuture={'device',get,'thermostatModeFuture',nil,true}\n        getProps.on={'device',call,'turnOn',mapF,true}\n        getProps.off={'device',call,'turnOff',mapF,true}\n        getProps.play={'device',call,'play',mapF,nil}\n        getProps.pause={'device',call,'pause',mapF,nil}\n        getProps.open={'device',call,'open',mapF,true}\n        getProps.close={'device',call,'close',mapF,true}\n        getProps.stop={'device',call,'stop',mapF,true}\n        getProps.secure={'device',call,'secure',mapF,false}\n        getProps.unsecure={'device',call,'unsecure',mapF,false}\n        getProps.isSecure={'device',on,'secured',mapAnd,true}\n        getProps.isUnsecure={'device',off,'secured',mapOr,true}\n        getProps.name={'device',function(id) return fibaro.getName(id) end,nil,nil,false}\n        getProps.partition={'alarm',function(id) return partition(id) end,nil,nil,false}\n        getProps.HTname={'device',function(id) return ER.reverseVar(id) end,nil,nil,false}\n        getProps.roomName={'device',function(id) return fibaro.getRoomNameByDeviceID(id) end,nil,nil,false}\n        getProps.trigger={'device',function() return true end,'value',nil,true}\n        getProps.time={'device',get,'time',nil,true}\n        getProps.manual={'device',function(id) return quickApp:lastManual(id) end,'value',nil,true}\n        getProps.start={'device',function(id) return fibaro.scene(\"execute\",{id}) end,\"\",mapF,false}\n        getProps.kill={'device',function(id) return fibaro.scene(\"kill\",{id}) end,\"\",mapF,false}\n        getProps.toggle={'device',toggle,'value',mapF,true}\n        getProps.wake={'device',call,'wakeUpDeadDevice',mapF,true}\n        getProps.removeSchedule={'device',call,'removeSchedule',mapF,true}\n        getProps.retryScheduleSynchronization={'device',call,'retryScheduleSynchronization',mapF,true}\n        getProps.setAllSchedules={'device',call,'setAllSchedules',mapF,true}\n        getProps.levelIncrease={'device',call,'startLevelIncrease',mapF,nil}\n        getProps.levelDecrease={'device',call,'startLevelDecrease',mapF,nil}\n        getProps.levelStop={'device',call,'stopLevelChange',mapF,nil}\n        getProps.type={'device',function(id) return ER.getDeviceInfo(id).type end,'type',mapF,nil}\n        \n        -- setProps helpers\n        local function set(id,cmd,val) fibaro.call(id,cmd,val); return val end\n        local function set2(id,cmd,val)\n            assert(type(val)=='table' and #val>=3,\"setColor expects a table with 3 values\")\n            fibaro.call(id,cmd,table.unpack(val)); \n            return val \n        end\n        local function setProfile(id,_,val) if val then fibaro.profile(\"activateProfile\",id) end return val end\n        local function setState(id,_,val) fibaro.call(id,\"updateProperty\",\"state\",val); return val end\n        local function setProps(id,cmd,val) fibaro.call(id,\"updateProperty\",cmd,val); return val end\n        local function dim2(id,_,val) ER.utilities.dimLight(id,table.unpack(val)) end\n        local function pushMsg(id,cmd,val) fibaro.alert(fibaro._pushMethod,{id},val); return val end\n        local function setAlarm(id,cmd,val) arm(id,val and 'arm' or 'disarm') return val end\n        helpers.set, helpers.set2, helpers.setProfile, helpers.setState, helpers.setProps, helpers.dim2, helpers.pushMsg = set, set2, setProfile, setState, setProps, dim2, pushMsg\n        \n        local setProps = {}\n        -- { function to get prop, property name }\n        setProps.R={set,'setR'} -- Don't think the RGBs are valid anymore...\n        setProps.G={set,'setG'}\n        setProps.B={set,'setB'}\n        setProps.W={set,'setW'}\n        setProps.value={set,'setValue'}\n        setProps.state={setState,'setState'}\n        setProps.prop={function(id,_,val) fibaro.call(id,\"updateProperty\",table.unpack(val)) end,'upDateProp'}\n\n        setProps.armed={setAlarm,'setAlarm'}\n\n        setProps.profile={setProfile,'setProfile'}\n        setProps.time={set,'setTime'}\n        setProps.power={set,'setPower'}\n        setProps.targetLevel={set,'setTargetLevel'}\n        setProps.interval={set,'setInterval'}\n        setProps.mode={set,'setMode'}\n        setProps.setpointMode={set,'setSetpointMode'}\n        setProps.defaultPartyTime={set,'setDefaultPartyTime'}\n        setProps.scheduleState={set,'setScheduleState'}\n        setProps.color={set2,'setColor'}\n        setProps.volume={set,'setVolume'}\n        setProps.position={set,'setPosition'}\n        setProps.positions={setProps,'availablePositions'}\n        setProps.mute={set,'setMute'}\n        setProps.thermostatSetpoint={set2,'setThermostatSetpoint'}\n        setProps.thermostatMode={set,'setThermostatMode'}\n        setProps.heatingThermostatSetpoint={set,'setHeatingThermostatSetpoint'}\n        setProps.coolingThermostatSetpoint={set,'setCoolingThermostatSetpoint'}\n        setProps.thermostatFanMode={set,'setThermostatFanMode'}\n        setProps.schedule={set2,'setSchedule'}\n        setProps.dim={dim2,'dim'}\n        fibaro._pushMethod = 'push'\n        setProps.msg={pushMsg,\"push\"}\n        setProps.defemail={set,'sendDefinedEmailNotification'}\n        setProps.btn={set,'pressButton'} -- ToDo: click button on QA?\n        setProps.email={function(id,_,val) local _,_ = val:match(\"(.-):(.*)\"); fibaro.alert('email',{id},val) return val end,\"\"}\n        setProps.start={function(id,_,val) \n            if isEvent(val) then \n                fibaro.postRemote(id,val) return true\n            else \n                fibaro.scene(\"execute\",{id}) return true\n            end\n        end,\"\"}\n        setProps.sim_pressed={function(id,_,val) fibaro.post({type='device',id=id,property='centralSceneEvent',value={keyId=val,keyAttribute='Pressed'}}) end,\"push\"} -- For simulated button presses\n        setProps.sim_helddown={function(id,_,val) fibaro.post({type='device',id=id,property='centralSceneEvent',value={keyId=val,keyAttribute='HeldDown'}}) end,\"push\"}\n        setProps.sim_released={function(id,_,val) fibaro.post({type='device',id=id,property='centralSceneEvent',value={keyId=val,keyAttribute='Released'}}) end,\"push\"}\n\n        setProps.isCat={function(id,_,val) return ER.getDeviceInfo(id).categories[val]==true end,\"...\"}\n        setProps.isInterf={function(id,_,val) return ER.getDeviceInfo(id).interfaces[val]==true end,\"...\"}\n\n        local filters = ER.propFilters\n        ER.propFilterTriggers = {}\n        local function NB(x) if type(x)=='number' then return x~=0 and 1 or 0 else return x end end\n        local function mapAnd(l) for _,v in ipairs(l) do if not NB(v) then return false end end return true end\n        local function mapOr(l) for _,v in ipairs(l) do if NB(v) then return true end end return false end\n        function filters.average(list) local s = 0; for _,v in ipairs(list) do s=s+BN(v) end return s\/#list end\n        function filters.sum(list) local s = 0; for _,v in ipairs(list) do s=s+BN(v) end return s end\n        function filters.allFalse(list) return not mapOr(list) end\n        function filters.someFalse(list) return not mapAnd(list)  end\n        function filters.allTrue(list) return mapAnd(list) end\n        function filters.someTrue(list) return mapOr(list)  end\n        function filters.mostlyTrue(list) local s = 0; for _,v in ipairs(list) do s=s+(NB(v) and 1 or 0) end return s>#list\/2 end\n        function filters.mostlyFalse(list) local s = 0; for _,v in ipairs(list) do s=s+(NB(v) and 0 or 1) end return s>#list\/2 end\n        function filters.bin(list) local s={}; for _,v in ipairs(list) do s[#s+1]=NB(v) and 1 or 0 end return s end\n        function filters.GV(list) local s={}; for _,v in ipairs(list) do s[#s+1]=GlobalV(v) end return s end\n        ER.propFilterTriggers.GV = true\n        function filters.QV(list) local s={}; for _,v in ipairs(list) do s[#s+1]=QuickAppV(v) end return s end\n        ER.propFilterTriggers.QV = true\n        function filters.id(list,ev) return next(ev) and ev.id or list end -- If we called from rule trigger collector we return whole list\n        local function collect(t,m)\n            if type(t)=='table' then\n                for _,v in pairs(t) do collect(v,m) end\n            else m[t]=true end\n        end\n        function filters.leaf(tree)\n            local map,res = {},{}\n            collect(tree,map)\n            for e,_ in pairs(map) do res[#res+1]=e end\n            return res \n        end\n\n        ------------- Device info cache --------------------------------\n        local deviceInfo = {}\n        local function revMap(l) local r={} for _,v in ipairs(l) do r[v]=true end return r end\n        local function mapDevice(d)\n            local ifs = revMap(d.interfaces or {})\n            local cats = revMap(d.properties.categories or {})\n            deviceInfo[d.id] = { interfaces=ifs, categories = cats, type=d.type, name=d.name, roomID=d.roomID, parentId=d.parentId, visible=d.visible, enabled=d.enabled}\n        end\n\n        local function getDeviceInfo(id)\n            if not deviceInfo[id] then mapDevice(__fibaro_get_device(id)) end\n            return deviceInfo[id] or { interfaces={}, categories = {}}\n        end\n        ER.getDeviceInfo = getDeviceInfo\n\n        for _,d in ipairs(__fibaro_get_devices()) do mapDevice(d) end\n\n        fibaro.event({type='deviceEvent',value='created'},function(env)\n            mapDevice(env.event.id)\n        end)\n \n        fibaro.event({type='deviceEvent',value='modified'},function(env)\n            mapDevice(env.event.id)\n        end)\n\n        fibaro.event({type='deviceEvent',value='removed'},function(env)\n            deviceInfo[env.event.id] = nil\n        end)\n\n        defVars.deviceInfo = function(id) return getDeviceInfo(id) end\n        --local function mapAnd2(f,l) for _,v in ipairs(l) do if not f(v) then return false end end return true end\n        function defVars.isCat(id,c) return getDeviceInfo(id).categories[c]==true end\n        ------------------------------------------------------\n\n        return getProps,setProps,helpers\n    end\n\n    -------------- builtin functions -------------------------\n    args.post = {1,3}\n    --D: post(event,time) => ref\n    function builtin.post(i,st,p) \n        local env,r=p.args[1] or {},nil\n        local args,n = st.popm(i[3]),i[3]\n        local e = args[1]\n        local t = args[2] or 0\n        local d = args[3] or env.rule or \"ER\"\n        eventCustomToString(e)\n        r = Script.post(p,e,t,d)\n        st.push(r)\n    end\n    args.cancel = {1,1}\n    --D: cancel(ref)\n    function builtin.cancel(i,st,p) Script.clearTimeout(p,st.pop()) st.push(nil) end\n    \n    local function encodeObj(o)\n        local mt = getmetatable(o)\n        if mt and mt.__tostring then return tostring(o) else return encodeFast(o) end \n    end\n    args.log = {1,99}\n    --D: log(format,...) => str\n    function builtin.log(i,st,p)\n        local args,n = st.popm(i[3]),i[3]\n        local opts = p.co.options or {}\n        local str = \"\"\n        for i=1,n do if type(args[i])=='table' then args[i]=encodeObj(args[i]) end end\n        --if #args < n then for i=1,n-#args do args[#args+1]='nil' end end\n        if n == 1 then str=tostring(args[1])\n        elseif #args>1 then\n            local stat,res = pcall(fmt,args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8])\n            if stat then str = res\n            else \n                res = res:gsub(\"bad argument #(%d+)\",function(n) return \"bad argument #\"..(n-1) end)\n                errorf(p,\"log format: %s\",res) \n            end \n        end\n        if opts.userLogColor then str = fmt(\"<font color=%s>%s<\/font>\",opts.userLogColor,str) end\n        local prFun = settings.userLogFunction or function(_,tag,str) fibaro.debug(tag,str) end\n        local stat,res = pcall(prFun,p.rule,p.rule and p.rule._ltag or ER.er.ltag or __TAG,str)\n        if not stat then errorf(p,\"userLogFunction: %s\",res) end\n        st.push(str)\n    end\n    args.elog = {1,99}\n    --D: elog(format,...) => str\n    function builtin.elog(i,st,p)\n        local args,n = st.popm(i[3],true),i[3]\n        local opts = p.co.options or {}\n        local stat,str = pcall(eformat,table.unpack(args))\n        if not stat then\n            str = str:gsub(\"#(%d+)\",function(n) return \"bad argument #\"..(n-1) end)\n            errorf(p,\"elog format: %s\",str) \n        end\n        if opts.userLogColor then str = fmt(\"<font color=%s>%s<\/font>\",opts.userLogColor,str) end\n        local prFun = settings.userLogFunction or fibaro.debug\n        local stat,res = pcall(prFun,p.rule,p.rule and p.rule._ltag or ER.er.ltag or __TAG,str)\n        if not stat then errorf(p,\"userLogFunction: %s\",res) end\n        st.push(str)\n    end\n\n    args.fmt = {1,99}\n    --D: fmt(format,...) => str\n    function builtin.fmt(i,st,p) st.push(fmt(table.unpack(st.lift(i[3],true)))) end\n    args.efmt = {1,99}\n    --D: efmt(format,...) => str\n    function builtin.efmt(i,st,p) st.push(eformat(table.unpack(st.lift(i[3],true)))) end\n    args.HM = {1,1}\n    --D: HM(time) => \"HH:MM\"\n    function builtin.HM(i,st,p) local t = st.pop(); st.push(os.date(\"%H:%M\",t < os.time()-8760*3600 and t+midnight() or t)) end  \n    args.HMS = {1,1}\n    --D: HMS(time) => \"HH:MM:SS\"\n    function builtin.HMS(i,st,p) local t = st.pop(); st.push(os.date(\"%H:%M:%S\",t < os.time()-8760*3600 and t+midnight() or t)) end  \n    args.sign = {1,1}\n    --D: sign(n) => 1 or -1\n    function builtin.sign(i,st,p) st.push(tonumber(st.pop()) < 0 and -1 or 1) end\n    args.rnd = {1,2}\n    --D: rnd(max,min) => n\n    function builtin.rnd(i,st,p) local ma,mi=st.pop(),i[3]>1 and st.pop() or 1 st.push(math.random(mi,ma)) end\n    args.round = {1,1}\n    --D: round(float) => int, rounded to nearest integer\n    function builtin.round(i,st,p) local v=st.pop(); st.push(math.floor(v+0.5)) end\n    args.sum = {1,1}\n    --D: sum(list) => n\n    function builtin.sum(i,st,p) local m,res=st.pop(),0 for _,x in ipairs(m) do res=res+x end st.push(res) end \n    args.average = {1,1}\n    --D: average(list) => n\n    function builtin.average(i,st,p) local m,res=st.pop(),0 for _,x in ipairs(m) do res=res+x end st.push(res\/#m) end \n    args.size = {1,1}\n    --D: size(list) => n\n    function builtin.size(i,st,p) st.push(#(st.pop())) end\n    args.min = {1,99}\n    --D: min(list) => n\n    function builtin.min(i,st,p) st.push(math.min(table.unpack(type(st.peek())=='table' and st.pop() or st.lift(i[3])))) end\n    args.max = {1,99}\n    --D: max(list) => n\n    function builtin.max(i,st,p) st.push(math.max(table.unpack(type(st.peek())=='table' and st.pop() or st.lift(i[3])))) end\n    args.sort = {1,99}\n    --D: sort(list) => list\n    function builtin.sort(i,st,p) local a = type(st.peek())=='table' and st.pop() or st.lift(i[3]); table.sort(a) st.push(a) end\n    --args.match = {2,2}\n    --function builtin.match(i,st,p) local a,b=st.pop(),st.pop(); st.push(string.match(b,a)) end\n    args.osdate = {0,1}\n    function builtin.osdate(i,st,p) local x,y = st.peek(i[3]-1),(i[3]>1 and st.pop() or nil) st.pop(); st.push(os.date(x,y)) end\n    args.ostime = {0,0}\n    function builtin.ostime(i,st,p) st.push(os.time()) end\n    args.global = {1,1}\n    function builtin.global(i,st)  \n        local name = st.pop()\n        local s = fibaro.getGlobalVariable(name)     \n        api.post(\"\/globalVariables\/\",{name=name})\n        st.push(s==nil)\n    end  \n    args.listglobals = {0,0}\n    function builtin.listglobals(i,st)  st.push(api.get(\"\/globalVariables\/\")) end\n    args.deleteglobal = {1,1}\n    function builtin.deleteglobal(i,st) st.push(api.delete(\"\/globalVariables\/\"..st.pop())) end\n    args.subscribe = {1,1}\n    function builtin.subscribe(i,st,p) fibaro.subscribe(st.pop()) st.push(true) end\n    args.publish = {1,2}\n    function builtin.publish(i,st,p) local e,t=st.pop(),nil; if i[3]==2 then t=e; e=st.pop() end fibaro.publish(e,t) st.push(e) end\n    args.remote = {2,2}\n    function builtin.remote(i,st,p) \n        local e,u=st.pop(),st.pop(); \n        fibaro.postRemote(u,e)\n        st.push(true) \n    end\n    args.add = {2,2}\n    function builtin.adde(i,st,p) local v,t=st.pop(),st.pop() table.insert(t,v) st.push(t) end\n    args.remove = {2,2}\n    function builtin.remove(i,st,p) local v,t=st.pop(),st.pop() table.remove(t,v) st.push(t) end\n    args.enable = {0,2}\n    function builtin.enable(i,st,p)\n        if i[3] == 0 then \n            p.rule.enable() \n            st.push(true) \n        else\n            local tag = st.popm(i[3])\n            st.push(ER.enable(tag[1]))\n        end\n    end\n    args.disable = {0,1}\n    function builtin.disable(i,st,p)\n        if i[3] == 0 then p.rule.disable() st.push(true) return end\n        local r = st.pop()\n        st.push(ER.disable(r))\n    end\n    args.yield = {0,99}\n    function builtin.yield(i,st,p) \n        local args = st.popm(i[3],true)\n        p.yielded = true; \n        st.push(args); \n        return 'multiple_values'\n    end\n    args.filter = {3,3}\n    function builtin.filter(i,st,p) \n        local out,list,cond = st.pop(),st.pop(),st.pop()\n        local v = p.env.get('_')[1]\n        if cond and out ~= nil then list[#list+1] = out end\n        st.push(out)\n    end\n    args.wait = {1,2}\n    function builtin.wait(i,st,p)\n        if not p.co then errorf(p,\"wait called outside of coroutine\") end\n        local args,n = st.popm(i[3]),i[3]\n        p.yielded = true;\n        args[1] = args[1] * 1000\n        st.push({\"%wait%\",args[1],args[2],args[3]}); return 'multiple_values'\n    end\n    args.once = {0,2}\n    function builtin.once(i,st,p) -- i[4] is last state\n        local n = i[3]            -- i[5] is optional timer to reset state\n        if n==1 then local f; i[4],f = st.pop(),i[4]; st.push(not f and i[4]) \n        elseif n==2 then \n            local f,g,e; e,i[4],f = st.pop(),st.pop(),i[4]; g=not f and i[4]; st.push(g) --ToDo verify args\n            if g then Script.cancel(p,i[5]) i[5]=Script.post(p,function() i[4]=nil end,e,\"once\") end\n        else \n            local f; i[4],f=os.date(\"%x\"),i[4] or \"\"; st.push(f ~= i[4]) -- once daily...\n        end\n    end\n    args.again = {0,1} \n    function builtin.again(i,st,p)\n        local env,n = p.args[1] or {},i[3]\n        local rule = env.rule\n        local flags = rule.trueForFlags or {}; rule.trueForFlags=flags\n        --- ToDo: check if again is called in a trueFor rule\n        local v = n>0 and st.pop() or math.huge\n        flags.again = (flags.again or 0)+1\n        if v > flags.again then setTimeout(function() rule.start0(flags.event) end,0) else flags.again,flags.even = nil,nil end\n        st.push(flags.again or v)\n    end\n    args.trueFor = {2,3}\n    function builtin.trueFor(i,st,p)\n        local args = st.popm(i[3])\n        local time,val,log = args[1],args[2],args[3]\n        log = log == true\n        local env = p.args[1] or {}\n        local id,rule,event = env.rule.id,env.rule,env.event\n        local flags = rule.trueForFlags or {}; rule.trueForFlags=flags\n        if val then\n            if flags.expired then -- we are called when timer has expired, return true and advance to action...\n                if log then env.co.LOG(\"trueFor true\") end\n                st.push(val);\n                flags.expired=nil;\n                return\n            end\n            if flags.timer then st.push(false); if log then print(\"trueFor waiting\") end return end -- still wating\n            flags.timer = Script.setTimeout(p,function()\n                flags.expired,flags.timer=true,nil; \n                Script.post(p,{type='trueFor',id=id,status='action',time=time,rule=rule,_sh=true})\n                rule.start0(event)\n            end,1000*time,\"trueFor\");\n            if log then env.co.LOG(\"trueFor started\") end\n            flags.event = event\n            Script.post(p,{type='trueFor',id=id,status='started',time=time,rule=rule,_sh=true})\n            st.push(false); return\n        else -- value false, cancel timer\n            if log then env.co.LOG(\"trueFor false\") end\n            if flags.timer then\n                flags.timer=Script.clearTimeout(p,flags.timer)\n                Script.post(p,{type='trueFor',id=id,status='cancelled',time=time,rule=rule,_sh=true})\n            end\n            st.push(false)\n        end\n    end\n    \n    ------------------ for loop builtins ---------------------\n    args.idxsetup = {3,3}\n    function builtin.idxsetup(i,st,p) -- 'idxsetup',{idx,sgv,stopv,stepv},{sav,sov,se})\n        local env = p.env\n        local idx,sgv,stopv,stepv = table.unpack(i,4)\n        local sav,sov,se = table.unpack((st.popm(i[3])))\n        env.push(idx,sav)\n        env.push(stopv,sov)\n        env.push(stepv,se)\n        env.push(sgv,se < 0 and -1 or 1)\n        st.push(true)\n    end\n    \n    args.idxcond = {0,0}\n    function builtin.idxcond(i,st,p) -- 'idxcond',{idx,sgv,stopv}),\n        local env = p.env\n        local idx,sgv,stopv = table.unpack(i,4)\n        idx,sgv,stopv = env.get(idx)[1],env.get(sgv)[1],env.get(stopv)[1]\n        st.push(idx*sgv <= stopv*sgv)\n    end\n    \n    args.idxinc = {0,0}\n    function builtin.idxinc(i,st,p) -- 'idxinc',{idx,sgv})\n        local env = p.env\n        local idx,stepv = table.unpack(i,4)\n        env.set(idx,env.get(idx)[1]+env.get(stepv)[1])\n        st.push(true)\n    end\n    \n    args.flsetup = {1,1}\n    function builtin.flsetup(i,st,p) -- 'flsetup',{kvar,vvar,fvar,lvar,svar},{expr})\n        local env = p.env\n        local kvar,vvar,fvar,lvar,svar = table.unpack(i,4)\n        local args = st.popm(1)\n        local f,l,s = args[1],args[2],args[3]\n        env.push(fvar,f)\n        env.push(lvar,l)\n        --env.push(svar,s)\n        env.push(kvar,s)\n        env.push(vvar,nil)\n        st.push(true)\n    end\n    \n    args.flinc = {0,0}\n    function builtin.flinc(i,st,p) -- 'flinc',{kvar,vvar,fvar,lvar},{})\n        local env = p.env\n        local kvar,vvar,fvar,lvar,v = table.unpack(i,4)\n        local k,f,l = env.get(kvar)[1],env.get(fvar)[1],env.get(lvar)[1]\n        if type(l)~='table' then errorf(p,\"ipairs expecting table - got %s\",type(l)) end\n        k,v = f(l,k)\n        env.set(kvar,k)\n        env.set(vvar,v)\n        st.push(true)\n    end\n    \n    --------------------------\n    \n    local function httpCall(cb,url,options,data,dflt)\n        local opts = table.copy(options)\n        opts.headers = opts.headers or {}\n        if opts.type then\n            opts.headers[\"content-type\"]=opts.type\n            opts.type=nil\n        end\n        if not opts.headers[\"content-type\"] then\n            opts.headers[\"content-type\"] = 'application\/json'\n        end\n        if opts.user and opts.pwd then \n            opts.headers['Authorization']= fibaro.utils.basicAuthorization((opts.user or \"\"),(opts.pwd or \"\"))\n            opts.user,opts.pwd=nil,nil\n        end\n        opts.data = data and json.encode(data)\n        --opts.checkCertificate = false\n        local basket = {}\n        net.HTTPClient():request(url,{\n            options=opts,\n            success = function(res0)\n                pcall(function()\n                    res0.data = json.decode(res0.data)  \n                end)\n                cb(res0.data or dflt,res0.status)\n            end,\n            error = function(err) cb(dflt,err) end\n        })\n        return opts.timeout and opts.timeout\/\/1000 or 30*1000,\"HTTP\"\n    end\n    \n    local http = {\n        get = ER.asyncFun(function(cb,url,options,dflt) options=options or {}; options.method=\"GET\" return httpCall(cb,url,options,dflt) end),\n        put = ER.asyncFun(function(cb,url,options,data,dflt) options=options or {}; options.method=\"PUT\" return httpCall(cb,url,options,data,dflt) end),\n        post = ER.asyncFun(function(cb,url,options,data,dflt) options=options or {}; options.method=\"POST\" return httpCall(cb,url,options,data,dflt) end),\n        delete = ER.asyncFun(function(cb,url,options,dflt) options=options or {}; options.method=\"DELETE\" return httpCall(cb,url,options,dflt) end),\n    }\n    defVars.http = http\n    \n    local function hc3api(cb,method,api,data)\n        local creds = defVars._creds\n        if not creds then setTimeout(function() cb(nil,404) end,0) end\n        net.HTTPClient():request(\"http:\/\/localhost\/api\"..api,{\n            options = {\n                method = method or \"GET\",\n                headers = {\n                    ['Accept'] = 'application\/json',\n                    [\"Authorization\"] = creds,\n                    ['X-Fibaro-Version'] = '2',\n                   -- [\"Content-Type\"] = \"application\/json\",\n                },\n                data = data and json.encode(data) or nil\n            },\n            success = function(resp)\n                cb(json.decode(resp.data),200)\n            end,\n            error = function(err)\n                cb(nil,err)\n            end\n        })\n    end\n\n    local api2 = {\n        get = ER.asyncFun(function(cb,path) return hc3api(cb,\"GET\",path,nil) end),\n        put = ER.asyncFun(function(cb,path,data) return hc3api(cb,\"PUT\",path,data) end),\n        post = ER.asyncFun(function(cb,path,data) return hc3api(cb,\"POST\",path,data) end),\n        delete = ER.asyncFun(function(cb,path) return hc3api(cb,\"DELETE\",path,nil) end),\n    }\n    defVars.hc3api = api2\n    defVars._hc3api = hc3api\n\n    ------------------ NoreRed support ---------------------------\n    local NR_trans = {}\n    function quickApp:fromNodeRed(ev)\n        ev = type(ev)=='string' and json.decode(ev) or ev\n        local tag = ev._transID\n        ev._IP,ev._async,ev._from,ev._transID=nil,nil,nil,nil\n        local f = NR_trans[tag]\n        if f then\n            NR_trans[tag] = nil\n            f(ev,200)\n        else fibaro.post(ev) end\n    end\n\n    --local noderedURL = \"http:\/\/192.168.1.128:1880\/ER_HC3\"\n    local function nodePost(event,cb)\n        event._from = quickApp.id\n        event._IP = fibaro.getIPaddress()\n        local noderedURL = defVars.noderedURL\n        assert(noderedURL,\"noderedURL not defined\")\n        local params =  {\n            options = {\n                headers = {['Accept']='application\/json',['Content-Type']='application\/json'},\n                data = json.encode(event), timeout=4000, method = 'POST'\n            },\n            success = function(res)\n                _,res.data = pcall(json.decode,res.data)\n                cb(res.status,res.data) \n            end,\n            error = function(err) cb(err) end\n        }\n        net.HTTPClient():request(noderedURL,params)\n    end\n\n   local function nodered(cb,event,dflt)\n        event = table.copy(event)\n        event._async = false\n        nodePost(event,function(status,data)\n            if status==200 then\n                cb(data,200)\n            else\n                cb(dflt,status)\n            end\n        end)\n        return 10*1000,\"NodeRed\"-- Timeout\n    end\n\n    local NRID = 1\n    local function nodered_as(cb,event,dflt)\n        event = table.copy(event)\n        event._async = true\n        event._transID = NRID; NRID=NRID+1\n        NR_trans[event._transID] = cb\n        nodePost(event,function(status,data)\n            if status==200 then\n            else\n                fibaro.warningf(__TAG,\"Nodered %s\",status)\n                NR_trans[event._transID] = nil\n                cb(dflt,status)\n            end\n        end)\n        return 10*1000,\"NodeRed\" -- Timeout\n    end\n    defVars.nr = { post = ER.asyncFun(nodered), post_as = ER.asyncFun(nodered_as) }\n    --------------------- end NR -----------------------\n\n    -- Interactive push notifications\n    local interactivePushTable = {}\n    function quickApp:INTERACTIVE_OK_BUTTON(tag,...)\n       if type(tag) ~= 'string' then return end\n       local cb = interactivePushTable[tag]\n       interactivePushTable[tag] = nil\n       if cb then\n          clearTimeout(cb[2])\n          cb[1](true) \n       end\n    end\n\n    local function pushYesNo(mobileId,title,message,tag)\n      api.post(\"\/mobile\/push\",{\n      category = \"YES_NO\", \n      title = title, \n      message = message, \n      service = \"Device\", \n      data = {\n        actionName = \"INTERACTIVE_OK_BUTTON\", \n        deviceId = quickApp.id,  \n        args = {tag}\n      }, \n      action = \"RunAction\",  \n        mobileDevices = { mobileId }, \n      })\n    end\n\n    defVars.ask = ER.asyncFun(function(cb,mobileId,title,message,timeout)\n      assert(tonumber(mobileId),\"ask: mobileId must be a number\")\n      assert(type(title)=='string',\"ask: title must be a string\")\n      assert(type(message)=='string',\"ask: message must be a string\")\n      timeout = timeout and timeout*1000 or 60*1000\n      local tag,ref = \"x\"..math.random(10000000)..os.time(),nil\n      pushYesNo(mobileId,title,message,tag)\n      ref = setTimeout(function()\n         local cb = interactivePushTable[tag]\n         interactivePushTable[tag]=nil\n         local stat,res = pcall(function()\n             if cb then cb[1](false) end \n             return true\n         end)\n         if not stat then print(\"err\",res) end\n       end\n      ,timeout)\n      interactivePushTable[tag]={cb,ref}\n      return timeout\n    end)\n    \n    --------------------- end interactive push -----------------------\n\n    local function getFibObj(path,p,k,v)\n        local oo = api.get(path) or {}\n        if p then oo = oo[p] end\n        for _,o in ipairs(oo or {}) do\n            if o[k]==v then return o end\n        end\n    end\n\n    local function enable(r,mode)\n        if ER.isRule(r) then return r[mode]()\n        elseif tonumber(r) and ER.rules[tonumber(r)] then\n            return ER.rules[tonumber(r)][mode]()\n        elseif type(r) == 'table' then\n            for _,r0 in ipairs(r) do enable(r0,mode) end\n        elseif type(r) == 'string' then\n            for id,r0 in ipairs(ER.rules) do\n                if r0._rtag == r then r0[mode]() end\n            end\n        else\n            error(mode..\": not a rule\")\n        end\n    end\n    \n    function ER.enable(r) return enable(r,'enable') end\n    function ER.disable(r) return enable(r,'disable') end\n\n    local tableInsert = table.insert\n    function table.insert(t,i,v) if v==nil then return tableInsert(t,i) else return tableInsert(t,i,v) end end\n\n    defVars.LOC = function(name) return getFibObj(\"\/panels\/location\",nil,\"name\",name) end\n    defVars.USER = function(name) return getFibObj(\"\/users\",nil,\"name\",name) end\n    defVars.PHONE = function(name) return getFibObj(\"\/iosDevices\",nil,\"name\",name) end\n    defVars.PART = function(name) return getFibObj(\"\/alarms\/v1\/partitions\",nil,\"name\",name) end\n    defVars.PROF = function(name) return getFibObj(\"\/profiles\",\"profiles\",\"name\",name) end\n    defVars.CLIM = function(name) return getFibObj(\"\/panels\/climate\",nil,\"name\",name) end\n    defVars.SPRINK = function(name) return getFibObj(\"\/panels\/sprinklers\",nil,\"name\",name) end\n\n    local function makeDateFun(str,cache)\n        if cache[str] then return cache[str] end\n        local f = fibaro.dateTest(str)\n        cache[str] = f\n        return f\n      end\n  \n    local cache = { date={}, day = {}, month={}, wday={} }\n    defVars.date = function(s) return (cache.date[s] or makeDateFun(s,cache.date))() end               -- min,hour,days,month,wday\n    defVars.day = function(s) return (cache.day[s] or makeDateFun(\"* * \"..s,cache.day))() end          -- day('1-31'), day('1,3,5')\n    defVars.month = function(s) return (cache.month[s] or makeDateFun(\"* * * \"..s,cache.month))() end  -- month('jan-feb'), month('jan,mar,jun')\n    defVars.wday = function(s) return (cache.wday[s] or makeDateFun(\"* * * * \"..s,cache.wday))() end   -- wday('fri-sat'), wday('mon,tue,wed')\n\n    defVars.S1 = {click = \"16\", double = \"14\", tripple = \"15\", hold = \"12\", release = \"13\"}\n    defVars.S2 = {click = \"26\", double = \"24\", tripple = \"25\", hold = \"22\", release = \"23\"}\n    defVars.catch = math.huge\n    function QuickApp:printTagAndColor(tag,color,fmt,...)\n        assert(fmt,\"print needs tag, color, and args\")\n        fmt = string.format(fmt,...)\n        local t = __TAG\n        __TAG = tag or __TAG\n        if hc3_emulator or not color then self:tracef(fmt,...) \n        else\n            self:trace(\"<font color=\"..color..\">\"..fmt..\"<\/font>\") \n        end\n        __TAG = t\n    end\n    defVars.printc = function(...) quickApp:printTagAndColor(...) end\n    defVars.QA = quickApp\n\n  definePropClass('Weather')\n  function Weather:__init() PropObject.__init(self) end\n  function Weather.getProp.temperature(id,prop,event) return fibaro.weather.temperature() end\n  function Weather.getProp.temperatureUnit(id,prop,event) return fibaro.weather.temperatureUnit() end\n  function Weather.getProp.humidity(id,prop,event) return fibaro.weather.humidity() end\n  function Weather.getProp.wind(id,prop,event) return fibaro.weather.wind() end\n  function Weather.getProp.condition(id,prop,event) return fibaro.weather.weatherCondition() end\n  function Weather.getProp.code(id,prop,event) return fibaro.weather.conditionCode() end\n\n  function Weather.trigger.temperature(id,prop) return {type='weather', property='Temperature'} end\n  function Weather.trigger.temperatureUnit(id,prop) return {type='weather', property='TemperatureUnit'} end\n  function Weather.trigger.humidity(id,prop) return {type='weather', property='Humidity'} end\n  function Weather.trigger.wind(id,prop) return {type='weather', property='Wind'} end\n  function Weather.trigger.condition(id,prop) return {type='weather', property='WeatherCondition'} end\n  function Weather.trigger.code(id,prop) return {type='weather', property='ConditionCode'} end\n\n  defVars.weather = Weather()\n\n  definePropClass('GlobalV')\n  function GlobalV:__init(name) PropObject.__init(self) self.name = name end\n  function GlobalV:__tostring() return fmt(\"GV(%s)\",self.name) end\n  function GlobalV.getProp.name(id,prop,event) return id.name end\n  function GlobalV.getProp.value(id,prop,event) return marshallFrom(fibaro.getGlobalVariable(id.name)) end\n  function GlobalV.getProp.delete(id,prop,event) return fibaro.getGlobalVariable(id.name) end\n  function GlobalV.setProp.value(id,prop,val) fibaro.setGlobalVariable(id.name,marshallTo(val)) return val end\n  function GlobalV.trigger.value(id,prop) return {type='globalVariable', name=id.name} end\n  defVars.GV = function(n) return GlobalV(n) end\n\n  definePropClass('QuickAppV')\n  function QuickAppV:__init(name) PropObject.__init(self) self.name = name end\n  function QuickAppV:__tostring() return fmt(\"QV(%s)\",self.name) end\n  function QuickAppV.getProp.name(id,prop,event) return id.name end\n  function QuickAppV.getProp.value(id,prop,event) return quickApp:getVariable(id.name) end\n  function QuickAppV.getProp.delete(id,prop,event) return quickApp:setVariable(id.name,nil) end\n  function QuickAppV.setProp.value(id,prop,val) quickApp:setVariable(id.name,val) return val end\n  function QuickAppV.trigger.value(id,prop) return {type='quickVar', name=id.name} end\n  defVars.QV = function(n) return QuickAppV(n) end\n\n  ----------- Child support ----------------\n  local ERchildren = {}\n  local function initChildren()\n    quickApp:initChildren(ERchildren)\n    for uid,c in pairs(quickApp.children) do \n        defVars[uid]=c.id\n        defVars[uid..\"_D\"]=c\n        defVars[uid..\"_ID\"]=c.id\n        local d = api.get(\"\/devices\/\"..c.id)\n        for name,_ in pairs(d.actions) do\n            c[name] = function(self,...) fibaro.post({type='UI',action=name,id=c.id,args={}}) end\n        end\n        c['prop'] = c.updateProperty\n    end\n  end\n\n  local function child(uid,name,typ)\n    ERchildren[uid] = {name=name,type=typ,className='QwikAppChild'}\n  end\n  defVars.child=child\n  defVars.initChildren=initChildren\n  \n  function ER.addStdPropFuns()\n    local stdPropObject = ER.stdPropObject\n    \n    local keyAttrMT = { \n        __tostring = function(t) return string.format(\"%s:%s\",t.id,t.attr) end,\n        __cmpVal = function(a) \n            return tostring(a)\n        end \n    }\n    function stdPropObject.getProp.key(id,prop,event)\n        return setmetatable({id=event.value.keyId,attr=event.value.keyAttribute},keyAttrMT) \n    end\n    function stdPropObject.trigger.key(self,id) return {type='device', id=id, property='centralSceneEvent'} end\n    \n    fibaro.customMessageIdMap={}\n    \n    function stdPropObject.setProp.msg(obj,prop,value)\n        local id = obj.id\n\n        if not fibaro.customMessage then\n            fibaro.alert(fibaro._pushMethod, {id}, value, false, '', false)\n        else\n            local map,user = fibaro.customMessageIdMap,nil\n            if type(map)=='table' then user = map[id]\n            elseif type(map) == \"function\" then\n                user = map(id,value)\n            end\n            assert(user,\"No user found for id \"..id)\n            fibaro.customMessage(user,value)\n        end\n        return value \n    end\n    \n    local appKey= \"an1e3cqj3g1gx9shr3wqeq8kj8ynhw\"\n    function fibaro.pushoverMessage(userid,msg)\n        --https:\/\/pushover.net\/api\n        local url,data = \"https:\/\/api.pushover.net\/1\/messages.json\",nil\n        local headers = {[\"Content-Type\"]=\"application\/json\"}\n        if type(msg) == 'string' then\n            data = {message=msg}\n        else\n            data = table.copy(msg)\n        end\n        data.token,data.user = fibaro.pushoverKey or appKey,userid\n        net.HTTPClient():request(url,{\n            options = {\n                method = 'POST',\n                headers = headers,\n                data = json.encode(data),\n                requireCertificate=false,\n            },\n            success = function(response)\n            end,\n            error = function(err)\n                fibaro.error(__TAG,string.format(\"Pushover %s %s %s\",err,json.encode(msg)))\n            end\n        })\n    end\n  end\nend","isMain":false},{"isOpen":false,"type":"lua","name":"utils","content":"fibaro.__ER  = fibaro.__ER or { modules={} }\n\nfunction fibaro.__ER.modules.utilities(ER)\n  \n  ER.utilities = {}\n  local Utils = ER.utilities\n  local extraSetups = {}\n  \n  local toTime,midnight,encodeFast = fibaro.toTime,fibaro.midnight,json.encodeFast\n  local fmt = string.format\n  \n  function Utils.evOpts(...) for _,v in pairs({...}) do if not v then return false end end return true end\n  \n  function Utils.stack()\n    local p,px,st,self=0,0,{},{}\n    function self.push(v) p=p+1 st[p]=v px=p end\n    function self.pop(n) n = n or 1; p=p-n; px=p return st[p+n] end\n    function self.pop2() local b,a = self.pop(),self.pop() return a,b end\n    function self.popn(n,v) v = v or {}; if n > 0 then local p0 = self.pop(); self.popn(n-1,v); v[#v+1]=p0 end return v end \n    function self.peek(n) return st[p-(n or 0)] end\n    function self.lift(n,pack) \n      local s = {}\n      for i=1,n do s[i]=st[p-n+i] end\n      self.pop(n) \n      return pack and {table.unpack(s,1,n)} or s -- deal with arrays with holes...\n    end -- Need to do this to get correct size of result table\n    function self.liftc(n) local s = {} for i=1,n do s[i] = st[p-n+i] end return s end\n    function self.isEmpty() return p<=0 end\n    function self.size() return p end    \n    function self.setSize(np) p=np; px=p end\n    function self.push0(v) px=px+1 st[px]=v end\n    function self.p2px(v) p=px end\n    function self.popm(n,pack) n=n or 1; local r,i0 ={},0 \n      for i=p-n+1,px do i0=i0+1; r[i0]=st[i] end  -- Need to do this to get correct size of result table\n      p=p-n; px=p \n      if pack then return {table.unpack(r,1,i0)},i0 else return r,i0 end\n    end\n    function self.get(i) return st[i] end\n    function self.dump() for i=1,p do print(string.format(\"S%02d: %s\",i,json.encode(st[i]))) end end\n    function self.clear() p,px,st=0,0,{} end\n    return self\n  end\n  \n  function Utils.stream(tab)\n    local p,self=0,{ stream=tab, eof={type='eof', value='', from=tab[#tab].from, to=tab[#tab].to} }\n    function self.next() p=p+1 local r = p<=#tab and tab[p] or self.eof; return r end\n    function self.last() return tab[p] or self.eof end\n    function self.prev() return tab[p-1] or self.eof end\n    function self.peek(n) return tab[p+(n or 1)] or self.eof end\n    function self.containsOp(op) for _,t in ipairs(tab) do if t.opval == op then return true end end end\n    return self\n  end\n  \n  local floor = math.floor\n  \n  local function htmlify(str,sp)\n    local cols,i = {},0\n    str = str:gsub(\"(<font .->)\",function(c) cols[#cols+1]=c return \"#CCC#\" end)\n    if sp then str = str:gsub(\" \",\"&nbsp;\") end\n    str = str:gsub(\"\\n\",\"<\/br>\")\n    return str:gsub(\"(#CCC#)\",function(c) i=i+1 return cols[i] end)\n  end\n  \n  local function LOGGER(df,sp,f,...)\n    if #{...} > 0 then\n      local msg = f:format(...)\n      msg = htmlify(msg,sp)\n      df(ER.settings.systemLogTag or __TAG,msg)\n      return msg\n    else \n      f = htmlify(f,sp)\n      df(ER.settings.systemLogTag or __TAG,f) \n      return f\n    end\n  end\n  \n  function Utils.LOG(f,...) return LOGGER(fibaro.trace,false,f,...) end\n  function Utils.LOGERR(f,...) return LOGGER(fibaro.error,true,f,...) end\n  \n  local LOG = Utils.LOG\n  local LOGERR = Utils.LOGERR\n  \n  function Utils.PrintBuffer(...)\n    local self = { buff = {...} }\n    local buff = self.buff\n    function self:printf(...) buff[#buff+1] = string.format(...) end\n    function self:add(v) buff[#buff+1] = tostring(v) end\n    function self:print(...)\n      local r={} for _,v in ipairs({...}) do r[#r+1] = tostring(v) end\n      buff[#buff+1] = table.concat(r,\" \")\n    end\n    function self:tostring(div) return table.concat(buff,div or \"\\n\") end\n    return setmetatable(self,{__tostring=function(obj) return obj:tostring() end})\n  end\n  \n  local function maxLen(list) local m = 0 for _,e in ipairs(list) do m=math.max(m,e:len()) end return m end\n  function Utils.htmlTableAlt(list,opts)\n    opts = opts or {}\n    local pr = Utils.PrintBuffer()\n    pr:printf(\"<table %s>\",opts.table or \"\")\n    for _,l in ipairs(list) do\n      pr:printf(\"<tr %s>\",opts.tr or \"\")\n      l = type(l)=='table' and l or {l}\n      for _,e in ipairs(l) do\n        pr:printf(\"<td %s>\",opts.td or \"\") pr:add(tostring(e)) pr:add(\"<\/td>\") \n      end\n      pr:add(\"<\/tr>\")\n    end\n    pr:add(\"<\/table>\")\n    return pr:tostring(\"\")\n  end\n\n---@diagnostic disable-next-line: undefined-field\n  if fibaro.fibemu then \n    function Utils.htmlTable(list,opts)\n      opts = opts or {}\n      local pr,cols,rows=Utils.PrintBuffer(),{},{}\n      for i,e in ipairs(list) do list[i]=type(e)=='table' and e or {e} end\n      for i=1,#list do\n        for j=1,#list[i] do\n          local e = list[i][j]\n          local s = e:split(\"\\n\")\n          list[i][j]=s\n          cols[j]=math.max(cols[j] or 0,maxLen(s))\n          rows[i]=math.max(rows[i] or 0,#s)\n        end\n      end\n      local s = \"+\"\n      for j=1,#cols do s=s..(\"-\"):rep(cols[j]+2)..\"+\" end -- Create line divider\n      pr:add(s)\n      for i=1,#list do  -- rows\n        for r=1,rows[i] do\n          local l = {}\n          for j=1,#list[i] do -- cols\n            local ll = list[i][j][r] or \"\"\n            l[#l+1]=ll..(\" \"):rep(cols[j]-ll:len())\n            --sp=\" |\"\n          end\n          pr:add(\"| \"..table.concat(l,\" | \")..\" |\")\n        end\n        pr:add(s)\n      end\n      return \"\\n\"..pr:tostring(\"\\n\")\n    end\n  else\n    Utils.htmlTable = Utils.htmlTableAlt\n  end\n  \n  function Utils.strPad(str,args,ch,w)\n    ch,w=ch or \"-\",w or 100\n    str = fmt(str,table.unpack(args or {}))\n    str = #str % 2 == 1 and str..\" \" or str\n    local n = #str+2\n    local l2=100\/2-n\/2\n    return string.rep(ch,l2)..\" \"..str..\" \"..string.rep(ch,l2)\n  end\n  \n  function Utils.makeBanner(str,args,ch,w) return Utils.strPad(str,args,ch,w) end\n---@diagnostic disable-next-line: undefined-field\n  if fibaro.fibemu then\n    function Utils.printBanner(str,args,col,ch,w) fibaro.debug(__TAG,fmt('\\n<font color=\"%s\">%s<\/font>',col or \"orange\",Utils.makeBanner(str,args,ch,w))) end\n  else\n    function Utils.printBanner(str,args,col,ch,w)\n      col=col or ER.settings.bannerColor or \"orange\"\n      str = fmt(\"<font color='black'>%s<\/font>\",str)\n      fibaro.debug(__TAG,Utils.htmlTable({fmt(str,table.unpack(args or {}))},{table=\"width='100%' border=1 bgcolor='\"..col..\"'\",td=\"align='center'\"}))\n    end\n  end\n  \n  local function table2str(t)\n    if type(t) == 'table' then\n      local mt = getmetatable(t)\n      if mt and mt.__tostring then return tostring(t)\n      else return encodeFast(t) end\n    else return tostring(t) end\n  end\n  function Utils.argsStr(...)\n    local args = {...}\n    local n = table.maxn(args)\n    if n == 0 then return \"nil\" end\n    local r = {} for i=1,n do r[i] = table2str(args[i]) end\n    return table.concat(r,\",\")\n  end\n  \n  local function shallowCopy(t) local r = {}; for k,v in pairs(t) do r[k]=v end; return r end\n  function Utils.eventStr(ev)\n    ev = shallowCopy(ev)\n    ev._trigger = nil\n    ev._sh = nil\n    local s = encodeFast(ev)\n    return fmt(\"#%s{%s}\",ev.type,s:match(\",(.*)}\") or \"\")\n  end\n  \n  function Utils.errorMsg(err)\n    err.class = err.type\n    err.type = 'error'\n    if err.src then err.srcInfo = err.srcInfo or Utils.errorLine(err.src,err.from,err.to) end\n    setmetatable(err,{__tostring=function(self)\n      local e = string.format(\"%s %s: %s\",self.rule and self.rule.longName or \"Expr\",self.class,self.msg)\n      if err.srcInfo then e = e..\"\\n\"..err.srcInfo end\n      return e\n    end})\n    return err\n  end\n  \n  function Utils.isErrorMsg(e) return type(e)=='table' and e.type == 'error' end\n  \n  function Utils.xerror(m,level) ER._lastErr = m error(m,level) end\n  \n  function Utils.pcall(f,...)\n    local stat = {pcall(f,...)}\n    if not stat[1] and ER._lastErr then\n      stat[3]=stat[2]\n      stat[2]=ER._lastErr\n      ER._lastErr = nil\n    end\n    return table.unpack(stat)\n  end\n  \n  function Utils.errorLine(str,from,to)\n    if not str:find(\"\\n\") then \n      if not(from or to) then return nil end\n      local msg = str..\"\\n\"\n      msg = msg..string.rep(\" \",from-1)..string.rep(\"^\",to-from+1)\n      return msg\n    else\n      if not(from or to) then return nil end\n      local n = 0\n      local lines = str:split(\"\\n\")\n      for _,l in ipairs(lines) do\n        if from >=n and from <= n+#l+1 then\n          from = from-n\n          to = to-n\n          local msg = l..\"\\n\"\n          msg = msg..string.rep(\" \",from-1)..string.rep(\"^\",to-from+1)\n          return msg\n        end\n        n = n+#l+1\n      end\n    end\n  end\n  \n  local MTevent = { __tostring = Utils.eventStr }\n  \n  local _customEvent = {\n    daily = { __tostring=function(self) return fmt(\"#daily{%s}\",self.id) end},\n    ['%interval%'] = { __tostring=function(self) return fmt(\"#interv{%s}\",self.id) end},\n    ['global-variable'] = { __tostring=function(self) return fmt(\"#GV{%s=%s}\",self.name,self.value \/\/ 30) end},\n    ['trigger-variable'] = { __tostring=function(self) return fmt(\"#TV{%s=%s}\",self.name,tostring(self.value) \/\/ 30) end},\n  }\n  function Utils.eventCustomToString(event)\n    if _customEvent[event.type] then return setmetatable(event,_customEvent[event.type]) end\n    return setmetatable(event,MTevent)\n  end\n  function ER.eventToString(type,fun)\n    _customEvent[type] = { __tostring=fun }\n  end\n  \n  local _marshalBool={['true']=true,['True']=true,['TRUE']=true,['false']=false,['False']=false,['FALSE']=false}\n  \n  function Utils.marshallFrom(v) \n    if not ER.settings.marshall then return v elseif v==nil then return v end\n    local fc = v:sub(1,1)\n    if fc == '[' or fc == '{' then local s,t = pcall(json.decode,v); if s then return t end end\n    if tonumber(v) then return tonumber(v)\n    elseif _marshalBool[v ]~=nil then return _marshalBool[v ] end\n    if v=='nil' then \n      return nil \n    end\n    local test = v:match(\"^[0-9%$s]\")\n    if not test then return v end\n    local s,t = pcall(toTime,v,true); return s and t or v \n  end\n  \n  local function safeEncode(s) local stat,res = pcall(json.encode,s) return stat and res or nil end\n  function Utils.marshallTo(v) \n    if not ER.settings.marshall then return tostring(v) end\n    if type(v)=='table' then return safeEncode(v) else return tostring(v) end\n  end\n  \n  ------- Patch fibaro.call to track manual switches -------------------------\n  local lastID,switchMap = {},{}\n  local oldFibaroCall = fibaro.call\n  function fibaro.call(id,action,...)\n    if ({turnOff=true,turnOn=true,on=true,toggle=true,off=true,setValue=true})[action] then lastID[id]={script=true,time=os.time()} end\n    if action=='setValue' and switchMap[id]==nil then\n      local actions = (__fibaro_get_device(id) or {}).actions or {}\n      switchMap[id] = actions.turnOff and not actions.setValue\n    end\n    if action=='setValue' and switchMap[id] then return oldFibaroCall(id,({...})[1] and 'turnOn' or 'turnOff') end\n    return oldFibaroCall(id,action,...)\n  end\n  \n  local function lastHandler(ev)\n    if ev.type=='device' and ev.property=='value' then\n      local last = lastID[ev.id]\n      local _,t = fibaro.get(ev.id,'value')\n      --if last and last.script then print(\"T:\"..(t-last.time)) end\n      if not(last and last.script and t-last.time <= 2) then\n        lastID[ev.id]={script=false, time=t}\n      end\n    end\n  end\n  \n  extraSetups[#extraSetups+1] = function()\n    fibaro.registerSourceTriggerCallback(lastHandler)\n  end\n  \n  function QuickApp:lastManual(id)\n    local last = lastID[id]\n    if not last then return -1 end\n    return last.script and -1 or os.time()-last.time\n  end\n  \n  -------------------------------------\n  local equations = {}\n  function equations.linear(t, b, c, d) return c * t \/ d + b; end\n  function equations.inQuad(t, b, c, d) t = t \/ d; return c * (t ^ 2) + b; end\n  function equations.inOutQuad(t, b, c, d) t = t \/ d * 2; return t < 1 and c \/ 2 * (t ^ 2) + b or -c \/ 2 * ((t - 1) * (t - 3) - 1) + b end\n  function equations.outInExpo(t, b, c, d) return t < d \/ 2 and equations.outExpo(t * 2, b, c \/ 2, d) or equations.inExpo((t * 2) - d, b + c \/ 2, c \/ 2, d) end\n  function equations.inExpo(t, b, c, d) return t == 0 and b or c * (2 ^ (10 * (t \/ d - 1))) + b - c * 0.001 end\n  function equations.outExpo(t, b, c, d) return t == d and  b + c or c * 1.001 * ((2 ^ (-10 * t \/ d)) + 1) + b end\n  function equations.inOutExpo(t, b, c, d)\n    if t == 0 then return b elseif t == d then return b + c end\n    t = t \/ d * 2\n    if t < 1 then return c \/ 2 * (2 ^ (10 * (t - 1))) + b - c * 0.0005 else t = t - 1; return c \/ 2 * 1.0005 * ((2 ^ (-10 * t)) + 2) + b end\n  end\n  \n  function Utils.dimLight(id,sec,dir,step,curve,start,stop)\n    assert(tonumber(sec), \"Bad dim args for deviceID:%s\",id)\n    local f = curve and equations[curve] or equations['linear']\n    dir,step = dir == 'down' and -1 or 1, step or 1\n    start,stop = start or 0,stop or 99\n    fibaro.post({type='%dimLight',id=id,sec=sec,dir=dir,fun=f,t=dir == 1 and 0 or sec,start=start,stop=stop,step=step,_sh=true})\n  end\n  \n  extraSetups[#extraSetups+1] = function()\n    fibaro.event({type='%dimLight'},function(env)\n      local e = env.event\n      local ev,currV = e.v or -1,tonumber(fibaro.getValue(e.id,\"value\"))\n      if not currV then\n        fibaro.warningf(__TAG,\"Device %d can't be dimmed. Type of value is %s\",e.id,type(fibaro.getValue(e.id,\"value\")))\n      end\n      if e.v and math.abs(currV - e.v) > 2 then return end -- Someone changed the lightning, stop dimming\n      e.v = math.floor(e.fun(e.t,e.start,(e.stop-e.start),e.sec)+0.5)\n      if ev ~= e.v then fibaro.call(e.id,\"setValue\",e.v) end\n      e.t=e.t+e.dir*e.step\n      if 0 <= e.t and  e.t <= e.sec then fibaro.post(e,os.time()+e.step) end\n    end)\n  end\n  ----------------------------\n  local sunInfo = {}\n  local lastDay = \"\"\n  function Utils.sunData()\n    local today = os.date(\"%x\")\n    if lastDay ~= today then\n      sunInfo.sunriseHour,sunInfo.sunsetHour,sunInfo.dawnHour,sunInfo.duskHour=fibaro.utils.sunCalc()\n      ---@diagnostic disable-next-line: cast-local-type\n      lastDay = today\n    end\n    return sunInfo\n  end\n  \n  local emulatedDevices = {}\n  do\n    local oldCall,oldGet = fibaro.call,__fibaro_get_device_property\n    function fibaro.call(id,...) \n      if emulatedDevices[id] then return emulatedDevices[id]:call(...) end\n      return oldCall(id,...) \n    end\n    function __fibaro_get_device_property(id,prop)\n      if emulatedDevices[id] then return {value=emulatedDevices[id]:get(prop),modified=emulatedDevices[id].modified} end\n      return oldGet(id,prop)\n    end\n    Utils.emulatedDevices = emulatedDevices\n  end\n\n  local traceCalls = { 'call', 'getVariable', 'setVariable','alarm','alert', 'emitCustomEvent', 'scene','profile' }\n  local nonSpeedCalls = { 'call','alarm','alert', 'scene', 'profile' }\n  local nonSpeedApis = { 'put','delete' }\n  for _,name in ipairs(traceCalls) do\n    local fun = fibaro[name]\n    fibaro[name] = function(...)\n      local stat = {true}\n      local virt = name=='call' and emulatedDevices[({...})[1] or \"\"]\n      if virt or (not nonSpeedCalls[name]) or (not ER.__speedTime) then\n        stat = {pcall(fun,...)}\n      end\n      if not stat[1] then error(stat[2]) end\n      if ER.settings.logFibaro then\n        local args = {...}\n        local str = string.eformat(\"Fibaro call: fibaro.%s(%l) = %l\",name,args,{table.unpack(stat,2)})\n        LOG(str)\n      end\n      return table.unpack(stat,2)\n    end \n  end\n  \n  for _,name in ipairs({'get','post','put','delete'}) do\n    local fun = api[name]\n    api[name] = function(...)\n      local stat = {true,{},200}\n      if not nonSpeedApis[name] or not ER.__speedTime then\n        stat = {pcall(fun,...)}\n      end\n      if not stat[1] then error(stat[2]) end\n      if ER.settings.logApi then \n        local args = {...}\n        for i=1,#args do if type(args[i])=='table' then args[i]=json.encode(args[i]) end end\n        local str = string.eformat(\"API call: api.%s(%l) = %,40l\",name,args,{json.encode(stat[2]),tostring(stat[3])})\n        LOG(str) \n      end\n      return table.unpack(stat,2)\n    end \n  end\n  \n  local timeOffset = 0\n\n  local oldTime,oldDate = os.time,os.date\n\n  function os.time(t) return t and oldTime(t) or oldTime()+timeOffset end\n  function os.date(s,b) return (not b) and oldDate(s,os.time()) or oldDate(s,b) end\n\n  function Utils.setTime(str) -- str = \"mm\/dd\/yyyy-hh:mm:ss\"\n    local function tn(s, v) return tonumber(s) or v end\n    local d, hour, min, sec = str:match(\"(.-)%-?(%d+):(%d+):?(%d*)\")\n    local month, day, year = d:match(\"(%d*)\/?(%d*)\/?(%d*)\")\n    local t = os.date(\"*t\")\n    t.isdst = false\n    t.year, t.month, t.day = tn(year, t.year), tn(month, t.month), tn(day, t.day)\n    t.hour, t.min, t.sec = tn(hour, t.hour), tn(min, t.min), tn(sec, 0)\n    local t1 = os.time(t)\n    local t2 = os.date(\"*t\", t1)\n    t.isdst = t2.isdst\n    t1 = os.time(t)\n    -- if t.isdst ~= t2.isdst then\n    --     t.isdst = t2.isdst\n    --     t1 = oldTime(t)\n    -- end\n   -- if t2.isdst then t1 = t1 + 3600 end\n    timeOffset = t1 - oldTime()\n  end\n\n  local runTimers,speedHours = nil,0\n  function Utils.speedTime(hours)\n    speedHours = hours\n    local startTime = os.time()*1000\n    timeOffset = 0\n    local endTime = startTime + hours*60*60*1000\n    local function milliseconds() return startTime+timeOffset end\n    function os.time(t) return t and oldTime(t) or math.floor(0.5+milliseconds()\/1000) end\n    function os.date(s,b) return (not b) and oldDate(s,os.time()) or oldDate(s,b) end\n    local oldSetTimeout,oldSetInterval = setTimeout,setInterval\n    local timerQueue = {}\n    function setTimeout(f,t)\n      t = milliseconds() + t\n      local ref = {f=f,t=t}\n      for i,e in ipairs(timerQueue) do\n        if e.t >  t then table.insert(timerQueue,i,ref) return ref end\n      end\n      timerQueue[#timerQueue+1] = ref\n      return ref\n    end\n    function runTimers()\n      local now = milliseconds()\n      while timerQueue[1] and timerQueue[1].t <= now do\n        local e = table.remove(timerQueue,1)\n        e.f()\n      end\n      if now > endTime then\n        fibaro.warning(__TAG,\" SpeedTime ended\")\n        timerQueue = {}\n        ER.__speedTime = false\n        os.time,os.date = oldTime,oldDate\n        setTimeout,setInterval = oldSetTimeout,oldSetInterval\n        ER.startMidnightScheduler()\n        return\n      end\n      if #timerQueue > 0 then\n        local t = timerQueue[1].t - now\n        if t < 0 then t = 0 end\n        timeOffset = timeOffset + t\n        oldSetTimeout(runTimers,0)\n      else\n        oldSetTimeout(runTimers,10)\n      end\n    end\n    function clearTimeout(ref)\n      for i,e in ipairs(timerQueue) do\n        if e == ref then table.remove(timerQueue,i) return end\n      end\n    end\n    ER.startMidnightScheduler()\n    ER.__speedTime = true\n  end\n  Utils.runTimers = function() \n    fibaro.warningf(__TAG,\" SpeedTime started (%shours)\",speedHours)\n    if runTimers then runTimers() end\n  end\n  ------------------------------------------------------\n  \n  ER.utilities.export = {\n    Utils.stack, Utils.stream, Utils.errorMsg, Utils.isErrorMsg, Utils.xerror, Utils.pcall, Utils.errorLine,\n    Utils.marshallFrom, Utils.marshallTo, toTime, midnight, encodeFast, Utils.argsStr, Utils.eventStr,\n    Utils.PrintBuffer, Utils.sunData, Utils.LOG, Utils.LOGERR, Utils.htmlTable, Utils.evOpts, Utils.eventCustomToString,\n    string.eformat\n  }\n  for _,f in ipairs(extraSetups) do f() end\n  \n  \n  -- stack,stream,errorMsg,isErrorMsg,e_error,e_pcall,errorLine,\n  -- marshallFrom,marshallTo,toTime,midnight,encodeFast,argsStr,eventStr,\n  -- PrintBuffer,sunData,LOG,LOGERR,htmlTable,evOpts,eventCustomToString,formatt =\n  -- table.unpack(ER.utilities.export)\n  \nend","isMain":false},{"isOpen":false,"type":"lua","name":"main","content":"_DEVELOP=\"..\/hc3emu\"\nif require and not QuickApp then require('hc3emu') end\n\n--%%name=MyQA\n--%%type=com.fibaro.binarySwitch\n--%%root=<automatic>\n--%%include=Include.lua\n--%%name=EventRunner5\n--%%uid=UPD896846032517892\n--%%save=EventRunner5.fqa\n--%%remote=alarms\/v1\/partitions:1\n--%%remote=profiles:*\n--%%debug=refresh:false\n--%%u1={label='title',text='EventRunner5'}\n--%%u2={{button='listRules',text='List rules', onReleased='listRules'},{button='listRulesExt',text='List rules ext.', onReleased='listRulesExt'}}\n--%%u3={{button='listTimers',text='List timers', onReleased='listTimers'},{button='listVars',text='List variables', onReleased='listVariables'}}\n--%%u4={{button='listRuleStats',text='List stats', onReleased='listRuleStats'},{button='Restart',text='Restart', onReleased='restart'}}\n--%%u5={label='stats',text=''}\n\nfunction QuickApp:main(er) -- Main function, place to define rules\n    local rule,eval,var,triggerVar,Util = er.eval,er.eval,er.variables,er.triggerVariables,er\n    self:enableTriggerType({\"device\",\"global-variable\",\"custom-event\",\"profile\",\"alarm\",\"weather\",\"location\",\"quickvar\",\"user\"}) -- types of events we want\n\n    -- example rules for main() - edit and create your own rules here\n    \n    local HT = { -- Test Home Table with \"fake\" devices - create your own...\n        keyfob = 46, \n        doorSensor = er.createBinaryDevice(),\n        temp = er.createMultilevelDevice(),\n        lux = er.createMultilevelDevice(),\n        roomlight = er.createMultilevelDevice(),\n        gardenlight = er.createBinaryDevice(),\n        frontlight = er.createBinaryDevice(),\n    }\n\n    -- er.setTime(\"03\/07\/2024 07:00\")\n    -- rule(\"log(osdate('%c'))\")\n\n    er.defvars(HT) -- Make HomeTable variables available as variables in rules. \n    er.reverseMapDef(HT)\n    --er.setTime(\"12\/01\/2023 12:00:00\") --mm\/dd\/yyyy-hh:mm:ss\n    --er.speedTime(2*24) -- 24 hours\n    -- rule([[#alarm{id='$id', property='breached'} =>  -- Log when a partition is breached\n    --     fibaro.warning(__TAG,efmt('BREACHED partition:%s',env.event.id))\n    -- ]])\n    -- rule([[#alarm{property='homeBreached'} =>   -- Log when home is breached\n    --     fibaro.warning(__TAG,efmt('BREACHED home'))\n    -- ]])\n\n    local msgOpts = { evalResult=false, userLogColor='yellow' }\n    local function expr(str) return rule(str,msgOpts) end -- Helper function to create non-logging expr with msgOpts\n\n    -- rule(\"keyfob:central.keyId == 1 => log('Keyfob button 1 pressed')\")\n    -- expr(\"wait(2); keyfob:sim_pressed=1\") -- Fake key press\n\n    expr(\"log('HC3 uptime %s',uptimeStr)\")\n    expr(\"elog('Sunrise at %t, Sunset at %t',sunrise,sunset)\")\n    expr(\"log('Weather is %s',weather)\")\n    expr(\"log('Weather condition is %s',weather:condition)\")\n    expr(\"log('Temperature is %s°',weather:temperature)\")\n    expr(\"log('Wind is %sms',weather:wind)\")\n    \n    -- At start, log all devices with battery < 50%\n    expr(\"elog('Devices with <50 battery are %l',[_:bat&_:bat<50,fmt('%s:%s',_,_:name) in devices])\")\n\n    var.i = 0 -- initialize ER variable\n    --rule(\"@@00:00:05 => i=i+1; log('ping: %s seconds',i*5)\",{ruleTrue=false}) -- test rule, ping every 5 seconds\n\n    R = rule(\"@now+10 => log('Ok %s',now+10)\").disable() -- Rule that triggers 10 seconds from now\n    R.enable()\n    R._setupDailys(true)\n\n    local ruleSet = {\n        rule(\"@sunset+00:10 => log('Ok, sunset+00:10')\"),\n        rule(\"@sunrise-00:10 => log('Ok, sunrise-00:10')\")\n    }\n\n    er.disable(ruleSet) -- Disable rules in ruleSet\n\n    -- rule(\"log('Time:%s',http.get('http:\/\/worldtimeapi.org\/api\/timezone\/Europe\/Stockholm').datetime)\")\n\n    local ruleOpts = { silent=true }\n    rule(\"#UI{cmd='listRules'} => listRules(false)\",ruleOpts)\n    rule(\"#UI{cmd='listRulesExt'} => listRules(true)\",ruleOpts)\n    rule(\"#UI{cmd='listVars'} => listVariables()\",ruleOpts)\n    rule(\"#UI{cmd='listTimers'} => listTimers()\",ruleOpts)\n    rule(\"#UI{cmd='listRuleStats'} => listStats()\",ruleOpts)\n    rule(\"#UI{cmd='Restart'} => plugin.restart()\",ruleOpts)\nend\n\nfunction QuickApp:onInit()\n    --fibaro.setupVariableCheck(true,4)\n    self:EventRunnerEngine( -- Create EventRunner engine and pass callback function \n    function(er)\n        -- Settings\n        \n        -- Global debug flags, can be overridden by ruleOptions\n        er.debug.ruleTrigger    = false -- log rules being triggered \n        er.debug.ruleTrue       = true  -- log rules with condition succeeding\n        er.debug.ruleFalse      = true  -- log rules with condition failing\n        er.debug.ruleResult     = false -- log results of rules running\n        er.debug.evalResult     = true  -- log results of evaluations\n        er.debug.post           = true  -- log events being posted\n        er.debug.sourceTrigger  = false  -- log incoming sourceTriggers\n        er.debug.refreshEvents  = false  -- log incoming refreshEvents\n        \n        -- Global settings\n        er.settings.marshall       = true          -- autoconvert globalVariables values to numbers, booleans, tables when accessed\n        --er.settings.systemLogTag   = \"ER\"..self.id -- log tag for ER system messages, defaults to __TAG\n        er.settings.ignoreInvisibleChars = false   -- Check code for invisible characters (xC2xA0) before evaluating\n        er.settings.truncLog       = 100           -- truncation of log output\n        er.settings.truncStr       = 80            -- truncation of log strings\n        -- er.settings.logFibaro      = true          -- log to fibaro.call, fibaro.setVariable, etc.\n        -- er.settings.logApi         = true          -- log all api.* calls\n        -- er.settings.bannerColor = \"orange\"         -- color of banner in log, defaults to \"orange\"      \n        -- er.settings.listColor = \"purple\"           -- color of list log (list rules etc), defaults to \"purple\"\n        -- er.settings.statsColor = \"green\"           -- color of statistics log, defaults to \"green\"  \n        -- er.settings.userLogFunction = function(rule,tag,str) return fibaro.debug(tag,str) end -- function to use for user log(), defaults to fibaro.debug if nil\n\n        -- Rule\/expresion options, overrides global settings when passed to individual rules\/expressions. nil means use global setting\n        -- local expressionOptions = {\n        --     listCode       = true,  -- list code when expression\/rule is created\n        --     trace          = false, -- trace code when expression\/rule is run\n        --     silent         = true,  -- don't log rule creation and rule results\n        --     ruleTrigger    = true,  -- log rule being triggered \n        --     ruleTrue       = true,  -- log rule when condition succeeds\n        --     ruleFalse      = true,  -- log rule when condition fails\n        --     ruleResult     = true,  -- log result of rule return value\n        --     evalResult     = true,  -- log result of expression evaluation\n        --     userLogColor   = 'yellow',  -- if set, wraps user log messages in color\n        -- }\n\n        local TRUE = er.color(\"lightgreen\",\"TRUE\")\n        local FALSE = er.color(\"lightred\",\"FALSE\")\n        function er.settings.runRuleLogFun(co,rule,ok,event)\n          co.LOG(\"%s %s -> %s\",ok and TRUE or FALSE,tostring(event) \/\/ 20,rule.src:gsub(\"\\n\",\"\") \/\/ 40)\n        end\n\n        function er.settings.userLogFunction(rule,tag,str) -- custom user log function with color and tag support,  #C:color# and #T:tag#\n          local color = nil\n          str = str:gsub(\"(#T:)(.-)(#)\",function(_,t) tag=t return \"\" end)\n          str = str:gsub(\"(#C:)(.-)(#)\",function(_,c) color=c return \"\" end)\n          if color then str=string.format(\"<font color=%s>%s<\/font>\",color,str) end\n          fibaro.debug(tag,str);\n          return str\n        end\n\n        --[[\n            Setup your own modules like this (or just add rules to main.lua):\n            In QA file 'u_myrules'  (u_ prefix is required)\n            \n            local prio = 2 -- lower prio loaded first..., prio < 0 loaded before 'main' and prio > 0 loaded after 'main', \n            local modulename = \"House rules\"\n\n            local function rules(self,er) -- self is the QA self\n                local rule,eval,var,triggerVar,Util = er.eval,er.eval,er.variables,er.triggerVariables,er\n\n                rule(...)\n                rule(...)\n                :\n            end\n\n            MODULES = MODULES or {}\n            MODULES[#MODULES+1]={name=modulename,prio=prio,loader=rules}\n        --]]\n    end\n)\nend","isMain":true}],"apiVersion":"1.3","type":"com.fibaro.genericDevice","name":"EventRunner5","initialProperties":{"viewLayout":{"$jason":{"body":{"header":{"style":{"height":"250"},"title":"quickApp_device_52"},"sections":{"items":[{"components":[{"text":"EventRunner5","visible":true,"type":"label","name":"title","style":{"weight":"1.2"}},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"components":[{"text":"List rules","visible":true,"type":"button","name":"listRules","style":{"weight":"0.50"}},{"text":"List rules ext.","visible":true,"type":"button","name":"listRulesExt","style":{"weight":"0.50"}}],"style":{"weight":"1.2"},"type":"horizontal"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"components":[{"text":"List timers","visible":true,"type":"button","name":"listTimers","style":{"weight":"0.50"}},{"text":"List variables","visible":true,"type":"button","name":"listVars","style":{"weight":"0.50"}}],"style":{"weight":"1.2"},"type":"horizontal"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"components":[{"text":"List stats","visible":true,"type":"button","name":"listRuleStats","style":{"weight":"0.50"}},{"text":"Restart","visible":true,"type":"button","name":"Restart","style":{"weight":"0.50"}}],"style":{"weight":"1.2"},"type":"horizontal"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"text":"","visible":true,"type":"label","name":"stats","style":{"weight":"1.2"}},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"}]}},"head":{"title":"quickApp_device_52"}}},"apiVersion":"1.3","useUiView":false,"typeTemplateInitialized":true,"uiCallbacks":[{"name":"listRules","callback":"listRules","eventType":"onReleased"},{"name":"listRules","callback":"","eventType":"onLongPressDown"},{"name":"listRules","callback":"","eventType":"onLongPressReleased"},{"name":"listRulesExt","callback":"listRulesExt","eventType":"onReleased"},{"name":"listRulesExt","callback":"","eventType":"onLongPressDown"},{"name":"listRulesExt","callback":"","eventType":"onLongPressReleased"},{"name":"listTimers","callback":"listTimers","eventType":"onReleased"},{"name":"listTimers","callback":"","eventType":"onLongPressDown"},{"name":"listTimers","callback":"","eventType":"onLongPressReleased"},{"name":"listVars","callback":"listVariables","eventType":"onReleased"},{"name":"listVars","callback":"","eventType":"onLongPressDown"},{"name":"listVars","callback":"","eventType":"onLongPressReleased"},{"name":"listRuleStats","callback":"listRuleStats","eventType":"onReleased"},{"name":"listRuleStats","callback":"","eventType":"onLongPressDown"},{"name":"listRuleStats","callback":"","eventType":"onLongPressReleased"},{"name":"Restart","callback":"restart","eventType":"onReleased"},{"name":"Restart","callback":"","eventType":"onLongPressDown"},{"name":"Restart","callback":"","eventType":"onLongPressReleased"}],"quickAppVariables":[],"quickAppUuid":"UPD896846032517892","uiView":[{"type":"horizontal","style":{"weight":"1.0"},"components":[{"text":"EventRunner5","style":{"weight":"1.0"},"type":"label","name":"title","visible":true}]},{"type":"horizontal","style":{"weight":"1.0"},"components":[{"eventBinding":{"onReleased":[{"params":{"actionName":"UIAction","args":["onReleased","listRules"]},"type":"deviceAction"}],"onLongPressDown":[{"params":{"actionName":"UIAction","args":["onLongPressDown","listRules"]},"type":"deviceAction"}],"onLongPressReleased":[{"params":{"actionName":"UIAction","args":["onLongPressReleased","listRules"]},"type":"deviceAction"}]},"style":{"weight":"0.5"},"type":"button","name":"listRules","visible":true,"text":"List rules"},{"eventBinding":{"onReleased":[{"params":{"actionName":"UIAction","args":["onReleased","listRulesExt"]},"type":"deviceAction"}],"onLongPressDown":[{"params":{"actionName":"UIAction","args":["onLongPressDown","listRulesExt"]},"type":"deviceAction"}],"onLongPressReleased":[{"params":{"actionName":"UIAction","args":["onLongPressReleased","listRulesExt"]},"type":"deviceAction"}]},"style":{"weight":"0.5"},"type":"button","name":"listRulesExt","visible":true,"text":"List rules ext."}]},{"type":"horizontal","style":{"weight":"1.0"},"components":[{"eventBinding":{"onReleased":[{"params":{"actionName":"UIAction","args":["onReleased","listTimers"]},"type":"deviceAction"}],"onLongPressDown":[{"params":{"actionName":"UIAction","args":["onLongPressDown","listTimers"]},"type":"deviceAction"}],"onLongPressReleased":[{"params":{"actionName":"UIAction","args":["onLongPressReleased","listTimers"]},"type":"deviceAction"}]},"style":{"weight":"0.5"},"type":"button","name":"listTimers","visible":true,"text":"List timers"},{"eventBinding":{"onReleased":[{"params":{"actionName":"UIAction","args":["onReleased","listVars"]},"type":"deviceAction"}],"onLongPressDown":[{"params":{"actionName":"UIAction","args":["onLongPressDown","listVars"]},"type":"deviceAction"}],"onLongPressReleased":[{"params":{"actionName":"UIAction","args":["onLongPressReleased","listVars"]},"type":"deviceAction"}]},"style":{"weight":"0.5"},"type":"button","name":"listVars","visible":true,"text":"List variables"}]},{"type":"horizontal","style":{"weight":"1.0"},"components":[{"eventBinding":{"onReleased":[{"params":{"actionName":"UIAction","args":["onReleased","listRuleStats"]},"type":"deviceAction"}],"onLongPressDown":[{"params":{"actionName":"UIAction","args":["onLongPressDown","listRuleStats"]},"type":"deviceAction"}],"onLongPressReleased":[{"params":{"actionName":"UIAction","args":["onLongPressReleased","listRuleStats"]},"type":"deviceAction"}]},"style":{"weight":"0.5"},"type":"button","name":"listRuleStats","visible":true,"text":"List stats"},{"eventBinding":{"onReleased":[{"params":{"actionName":"UIAction","args":["onReleased","Restart"]},"type":"deviceAction"}],"onLongPressDown":[{"params":{"actionName":"UIAction","args":["onLongPressDown","Restart"]},"type":"deviceAction"}],"onLongPressReleased":[{"params":{"actionName":"UIAction","args":["onLongPressReleased","Restart"]},"type":"deviceAction"}]},"style":{"weight":"0.5"},"type":"button","name":"Restart","visible":true,"text":"Restart"}]},{"type":"horizontal","style":{"weight":"1.0"},"components":[{"text":"","style":{"weight":"1.0"},"type":"label","name":"stats","visible":true}]}]},"initialInterfaces":["quickApp"]}